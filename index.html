<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>小野原彩香の研究系統樹 - Enhanced Visual</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@300;400;500;600&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=Sawarabi+Mincho&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=Shippori+Mincho:wght@400;500;600;700;800&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=Klee+One:wght@400;600&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: "Shippori Mincho", "Sawarabi Mincho", "ヒラギノ明朝 Pro", "Hiragino Mincho Pro", serif;
            background: #f5f5f5;
            min-height: 100vh;
            color: #333333;
            position: relative;
            overflow-x: hidden;
        }
        
        @keyframes subtle-fade {
            0%, 100% { opacity: 0.8; }
            50% { opacity: 1; }
        }
        
        @keyframes metallic-shimmer {
            0% { filter: url(#goldLeaf) brightness(1); }
            50% { filter: url(#goldLeaf) brightness(1.3); }
            100% { filter: url(#goldLeaf) brightness(1); }
        }
        
        @keyframes petal-wave {
            0% { transform: scale(1) rotate(0deg); }
            50% { transform: scale(1.1) rotate(5deg); }
            100% { transform: scale(1) rotate(0deg); }
        }
        
        .node-circle.level-0 {
            animation: metallic-shimmer 4s ease-in-out infinite;
        }
        
        .node:hover .petal {
            animation: petal-wave 0.8s ease-in-out;
            animation-delay: calc(var(--petal-index) * 0.1s);
        }

        .container {
            max-width: 1800px;
            margin: 0 auto;
            padding: 30px 20px;
        }

        .main-title {
            text-align: center;
            margin-bottom: 40px;
            background: #ffffff;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            position: relative;
        }

        .main-title h1 {
            font-family: "Klee One", "Shippori Mincho", "ヒラギノ明朝 Pro", serif;
            font-size: 2.8em;
            color: #333333;
            font-weight: 600;
            margin-bottom: 15px;
            letter-spacing: 0.05em;
            position: relative;
        }

        .main-title h1::after {
            content: '';
            position: absolute;
            bottom: -8px;
            left: 50%;
            transform: translateX(-50%);
            width: 100px;
            height: 3px;
            background: linear-gradient(90deg, transparent, #d4af37, transparent);
        }

        .subtitle {
            font-family: "Sawarabi Mincho", "ヒラギノ明朝 Pro", serif;
            font-size: 1.1em;
            color: #666666;
            font-weight: 400;
            letter-spacing: 0.03em;
        }

        .chart-container {
            background: #ffffff;
            border-radius: 12px;
            padding: 30px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            margin-bottom: 30px;
            overflow-x: auto;
            position: relative;
        }

        .tree-svg {
            width: 100%;
            height: 1000px;
            min-width: 1600px;
            cursor: move;
        }
        
        .svg-container {
            width: 100%;
            overflow-x: auto;
            overflow-y: hidden;
        }

        .node {
            cursor: pointer;
        }

        .node-circle {
            transition: all 0.3s ease;
        }

        .node:hover .node-circle {
            stroke-width: 3;
            transform: scale(1.1);
        }

        /* 開花効果のための装飾要素 */
        .flower-decoration {
            opacity: 0;
            transform: scale(0) rotate(0deg);
            transition: all 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            transform-origin: center;
        }

        .node:hover .flower-decoration {
            opacity: 1;
            transform: scale(1) rotate(180deg);
        }

        .petal {
            fill: #d4af37;
            opacity: 0.6;
            mix-blend-mode: multiply;
        }

        .node-text {
            font-family: "Shippori Mincho", "Sawarabi Mincho", "ヒラギノ明朝 Pro", serif;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        .node-text.visible {
            opacity: 1;
        }
        
        .node-text.fixed {
            opacity: 1 !important;
        }

        .link {
            fill: none;
            transition: all 0.3s ease;
        }

        .link:hover {
            opacity: 0.8;
        }

        .paper-indicator {
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .paper-indicator:hover {
            transform: scale(1.2);
        }

        .paper-tooltip {
            position: absolute;
            background: #ffffff;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            padding: 20px;
            font-size: 0.85em;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease;
            z-index: 1001;
            max-width: 500px;
            min-width: 300px;
            max-height: 600px;
            overflow-y: auto;
        }

        .paper-tooltip.visible {
            opacity: 1;
        }

        .paper-tooltip h4 {
            color: #333333;
            font-size: 1.1em;
            margin-bottom: 15px;
            font-weight: 600;
            border-bottom: 2px solid #2563eb;
            padding-bottom: 8px;
        }

        .paper-item {
            margin-bottom: 12px;
            padding: 8px 12px;
            background: #f8f8f8;
            border-radius: 6px;
            border-left: 3px solid #2563eb;
        }

        .paper-title {
            font-weight: 600;
            color: #333333;
            margin-bottom: 4px;
            line-height: 1.3;
            font-size: 0.9em;
        }

        .paper-meta {
            color: #666666;
            font-size: 0.85em;
            font-style: italic;
        }

        .paper-count {
            background: #2563eb;
            color: #ffffff;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 0.8em;
            font-weight: 600;
        }

        .tooltip {
            position: absolute;
            background: #ffffff;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            padding: 12px;
            font-size: 0.9em;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease;
            z-index: 1000;
            max-width: 300px;
            color: #333333;
        }

        .tooltip.visible {
            opacity: 1;
        }

        .chart-note {
            text-align: center;
            color: #666666;
            font-size: 0.9em;
            margin-top: 20px;
            padding: 15px;
            background: #f8f8f8;
            border-radius: 8px;
        }

        .info-section {
            background: #ffffff;
            border-radius: 12px;
            padding: 30px;
            margin: 30px 0;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        .info-section h3 {
            color: #333333;
            font-size: 1.8em;
            margin-bottom: 20px;
            text-align: center;
            font-weight: 600;
        }

        .timeline-items {
            display: grid;
            gap: 15px;
        }

        .timeline-item {
            background: #f8f8f8;
            border-radius: 8px;
            padding: 20px;
            border-left: 4px solid #2563eb;
            transition: all 0.3s ease;
            color: #333333;
        }

        .timeline-item:hover {
            transform: translateX(5px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
        }

        .year {
            font-weight: 600;
            color: #2563eb;
            font-size: 1.1em;
        }

        .legend {
            position: absolute;
            bottom: 60px;
            left: 300px;
            background: #ffffff;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            padding: 15px;
            font-size: 0.85em;
            z-index: 10;
            color: #333333;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
            font-size: 0.8em;
            color: #333333;
        }

        .legend-item:last-child {
            margin-bottom: 0;
        }

        .legend-circle {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            margin-right: 8px;
            flex-shrink: 0;
        }

        .controls {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: #ffffff;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            padding: 15px;
            font-size: 0.85em;
            z-index: 10;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .controls button {
            background: #2563eb;
            color: #ffffff;
            border: none;
            border-radius: 6px;
            padding: 8px 16px;
            margin: 0 5px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.85em;
        }

        .controls button:hover {
            background: #1d4ed8;
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        @media (max-width: 768px) {
            .container {
                padding: 20px 15px;
            }
            
            .main-title h1 {
                font-size: 2.2em;
            }
            
            .tree-svg {
                height: 700px;
            }
            
            .main-title {
                padding: 20px;
            }
            
            .chart-container {
                padding: 20px;
            }
            
            .legend {
                position: static;
                margin-bottom: 20px;
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="main-title">
            <h1>🌳 小野原彩香の研究系統樹</h1>
            <div class="subtitle">根から幹、枝を経て葉へと成長する研究の系統発生 - 力学的配置により自然に広がる知識の樹</div>
            <p><a href="https://en.wikipedia.org/wiki/The_Tree_of_Life,_Stoclet_Frieze">クリムトの生命の樹</a>、<a href="[https://tarabooks.com/shop/the-night-life-of-trees/]">夜の木</a>、<a href="[https://ja.wikipedia.org/wiki/%E3%83%A2%E3%83%81%E3%83%A2%E3%83%81%E3%81%AE%E6%9C%A8]">モチモチの樹</a>などをイメージして作成しています。</p>
        </div>
        
        <div class="chart-container">
            <div class="legend">
                <div class="legend-item">
                    <div class="legend-circle" style="background: #b8860b;"></div>
                    <span>根（研究者）</span>
                </div>
                <div class="legend-item">
                    <svg width="40" height="16" style="vertical-align: middle; margin-right: 8px;">
                        <line x1="0" y1="8" x2="40" y2="8" stroke="#8B6914" stroke-width="4" stroke-linecap="round"/>
                    </svg>
                    <span>幹・枝</span>
                </div>
                <div class="legend-item" style="margin-top: 10px; padding-top: 10px; border-top: 1px solid #e0e0e0;">
                    <span style="color: #666666;">論文ノード：年代別の色</span>
                </div>
                <div class="legend-item">
                    <div class="legend-circle" style="background: #93c5fd;"></div>
                    <span style="font-size: 0.7em;">2010-2012年</span>
                </div>
                <div class="legend-item">
                    <div class="legend-circle" style="background: #60a5fa;"></div>
                    <span style="font-size: 0.7em;">2013-2015年</span>
                </div>
                <div class="legend-item">
                    <div class="legend-circle" style="background: #3b82f6;"></div>
                    <span style="font-size: 0.7em;">2016-2018年</span>
                </div>
                <div class="legend-item">
                    <div class="legend-circle" style="background: #2563eb;"></div>
                    <span style="font-size: 0.7em;">2019-2022年</span>
                </div>
                <div class="legend-item">
                    <div class="legend-circle" style="background: #1e40af;"></div>
                    <span style="font-size: 0.7em;">2023-2024年</span>
                </div>
                <div class="legend-item" style="margin-top: 10px; padding-top: 10px; border-top: 1px solid rgba(255,255,255,0.3);">
                    <span style="font-size: 0.7em; color: #FFD700;">🍃 葉っぱ：論文</span>
                </div>
                <div class="legend-item" style="margin-top: 10px; padding-top: 10px; border-top: 1px solid rgba(255,255,255,0.3);">
                    <span style="font-size: 0.7em; color: #FFD700;">操作方法</span>
                </div>
                <div class="legend-item">
                    <span style="font-size: 0.7em;">・ノードをホバー：テキスト表示</span>
                </div>
                <div class="legend-item">
                    <span style="font-size: 0.7em;">・ノードをクリック：表示固定</span>
                </div>
                <div class="legend-item">
                    <span style="font-size: 0.7em;">・背景をクリック：全解除</span>
                </div>
            </div>
            <div class="controls">
                <button id="restart-simulation">配置をリセット</button>
                <button id="freeze-simulation">配置を固定</button>
                <button id="reset-zoom">表示をリセット</button>
            </div>
            <svg class="tree-svg" id="tree-chart"></svg>
            <div class="chart-note">
                🌳 力学的配置により自然に広がる研究系統樹<br>
                🔍 ノードをドラッグして配置を調整できます<br>
                📝 ノードにマウスを重ねるとテキストが表示され、クリックで表示を固定できます<br>
                🍃 葉っぱは論文を表し、新しい研究ほど鮮やかな緑色になります
            </div>
        </div>

        <div class="info-section">
            <h3>📅 研究発展の時系列</h3>
            <div class="timeline-items">
                <div class="timeline-item">
                    <span class="year">2024年:</span> 対話型AIモデルと音声技術の教育応用
                </div>
                <div class="timeline-item">
                    <span class="year">2023年:</span> ベイジアン系統発生解析論文 (Journal of Language Evolution)
                </div>
                <div class="timeline-item">
                    <span class="year">2022年:</span> 進化的アプローチによるアクセント機能研究開始
                </div>
                <div class="timeline-item">
                    <span class="year">2018-2023年:</span> 集団構造を考慮した言語変化プロセス研究
                </div>
                <div class="timeline-item">
                    <span class="year">2016-2019年:</span> 言語変化要因と系譜の定量的評価研究
                </div>
                <div class="timeline-item">
                    <span class="year">2013-2017年:</span> 数理的アプローチによる言語動態研究（博士研究）
                </div>
                <div class="timeline-item">
                    <span class="year">2010-2013年:</span> 方言分布・文化領域分析の基礎研究
                </div>
            </div>
        </div>
    </div>

    <div class="tooltip" id="tooltip"></div>
    <div class="paper-tooltip" id="paper-tooltip"></div>

    <script>
        // 研究データ（論文情報付き）
        const treeData = {
            name: '小野原彩香',
            description: '言語学・文化進化・データサイエンス研究者',
            level: 0,
            children: [
                {
                    name: '文化進化理論',
                    description: '文化伝達モデル・定量分析',
                    level: 1,
                    children: [
                        {
                            name: '言語進化研究',
                            description: 'ベイジアン系統発生解析・アクセント研究',
                            level: 2,
                            children: [
                                { 
                                    name: 'アクセント系統発生学', 
                                    description: 'ベイジアン系統発生解析によるピッチアクセントシステム', 
                                    level: 3,
                                    papers: [
                                        {
                                            title: 'Bayesian phylogenetic analysis of pitch-accent systems based on accentual class merger: a new method applied to Japanese dialects',
                                            journal: 'Journal of Language Evolution',
                                            year: '2024',
                                            details: '8(2) 169-191, 査読有り'
                                        },
                                        {
                                            title: 'Inferring the temporal and spatial evolution of accent systems in Japanese dialects: a phylogeographic approach',
                                            journal: 'Proceedings of the Joint Conference on Language Evolution',
                                            year: '2022',
                                            details: '査読有り'
                                        }
                                    ]
                                },
                                { 
                                    name: '方言の時空間変異', 
                                    description: '日本語方言のアクセントシステムの時空間進化', 
                                    level: 3,
                                    papers: [
                                        {
                                            title: '言語の消失と獲得に関連する環境・社会的要因',
                                            journal: 'GIS－理論と応用',
                                            year: '2016',
                                            details: '24(2), 招待有り'
                                        },
                                        {
                                            title: '日本語方言の推定されたアクセント類別の併合率の系統地理',
                                            journal: 'GIS－理論と応用',
                                            year: '2016',
                                            details: '24(2), 招待有り'
                                        },
                                        {
                                            title: 'ネットワーク上の文化伝達モデルによる日本語アクセント様式の変異率・系統関係の推定',
                                            journal: '国立国語研究所 時空間変異研究系 合同研究発表会 JLVC2012 予稿集',
                                            year: '2012',
                                            details: '43-46, 査読有り'
                                        }
                                    ]
                                },
                                { 
                                    name: '言語変化モデル', 
                                    description: '数理的アプローチによる言語動態', 
                                    level: 3,
                                    papers: [
                                        {
                                            title: '数理的アプローチからの言語変化と外言語的要素との関わりに関する研究',
                                            journal: '',
                                            year: '2014',
                                            details: '査読有り筆頭著者'
                                        },
                                        {
                                            title: '交通系統計情報の分布と言語外的要素に関する研究',
                                            journal: '情報処理学会シンポジウム論文集',
                                            year: '2010',
                                            details: '2010(15) 239-246, 査読有り'
                                        }
                                    ]
                                }
                            ]
                        },
                        {
                            name: 'GIS・空間分析',
                            description: '地理情報システム・機械学習応用',
                            level: 2,
                            children: [
                                { 
                                    name: 'ワイン栽培適地', 
                                    description: '機械学習を用いたワイン用ブドウ栽培適地推定', 
                                    level: 3,
                                    papers: [
                                        {
                                            title: '機械学習を用いたワイン用ブドウ栽培適地の推定',
                                            journal: 'GIS-理論と応用',
                                            year: '2023',
                                            details: '31(2) 78-78, 招待有り'
                                        },
                                        {
                                            title: 'CLIENT-SIDE WEB MAPPING SYSTEM FOR VINEYARD SUITABILITY ASSESSMENT',
                                            journal: 'The International Archives of the Photogrammetry, Remote Sensing and Spatial Information Sciences',
                                            year: '2022',
                                            details: 'XLVIII-4/W1-2022 223-228, 査読有り'
                                        }
                                    ]
                                },
                                { 
                                    name: '空間言語学', 
                                    description: '言語変化の地理的パターン', 
                                    level: 3,
                                    papers: [
                                        {
                                            title: '言語の消失と獲得に関連する環境・社会的要因',
                                            journal: '地理情報システム学会講演論文集(CD-ROM)',
                                            year: '2016',
                                            details: '25 40-40, 筆頭著者責任著者'
                                        },
                                        {
                                            title: '方言分布から見た文化事象の流通と滞留―岐阜県における方言分布の事例―',
                                            journal: '地理情報システム学会講演論文集(CD-ROM)',
                                            year: '2010',
                                            details: '19, 473-480'
                                        }
                                    ]
                                },
                                {
                                    name: 'AI・教育技術',
                                    description: 'データサイエンス教育・AI応用',
                                    level: 3,
                                    papers: [
                                        {
                                            title: '対話型AIモデル並びにAI音声を活用した教育コンテンツ作成 ―AI技術の新たな展開―',
                                            journal: '社会と統計',
                                            year: '2024',
                                            details: '(10) 27-44'
                                        },
                                        {
                                            title: 'Python を利用した地理総合実習コンテンツの作成',
                                            journal: '日本地理学会発表要旨集',
                                            year: '2023',
                                            details: '2023s. P007'
                                        }
                                    ]
                                }
                            ]
                        },
                        { 
                            name: '文化多様性機構', 
                            description: '文化的多様性の進化メカニズム', 
                            level: 2,
                            papers: [
                                {
                                    title: '雑誌「行動計量学」における言語に関する投稿論文の傾向',
                                    journal: '日本行動計量学会大会発表論文抄録集',
                                    year: '2012',
                                    details: '40 415-418'
                                }
                            ]
                        },
                        { 
                            name: '文化伝達ネットワーク', 
                            description: 'ネットワーク上の文化伝達モデル', 
                            level: 2,
                            papers: [
                                {
                                    title: 'ITMAにおけるNCDの実用性とUMLを用いた分析プロセスの可視化と共有について',
                                    journal: '情報処理学会シンポジウム論文集',
                                    year: '2010',
                                    details: '2010(15) 239-246, 査読有り'
                                },
                                {
                                    title: '岐阜県旧徳山村におけるアクセント様相と交通状況との関係性-ネットワーク分析を用いたアクセント分布と交通状況の類似性の算出-',
                                    journal: '情報処理学会シンポジウム論文集',
                                    year: '2011',
                                    details: '2011(8) 219-224, 査読有り筆頭著者'
                                }
                            ]
                        },
                        { 
                            name: '定量的方言学', 
                            description: '岐阜県方言語彙による文化領域抽出', 
                            level: 2,
                            papers: [
                                {
                                    title: '岐阜県方言語彙による仮想的文化領域抽出と語彙変化の方向',
                                    journal: '研究報告人文科学とコンピュータ（CH）',
                                    year: '2012',
                                    details: '2012(4) 1-6, 筆頭著者'
                                },
                                {
                                    title: '揖斐川上流域における語彙の類型と地理的分布',
                                    journal: '文化情報学',
                                    year: '2012',
                                    details: '8(1) 1-11, 査読有り筆頭著者'
                                },
                                {
                                    title: '揖斐川上流域の語彙に関する系統推定',
                                    journal: '研究報告人文科学とコンピュータ（CH）',
                                    year: '2012',
                                    details: '2012(4) 1-6'
                                }
                            ]
                        }
                    ]
                }
            ]
        };

        class TreeChart {
            constructor(svgId, data) {
                this.svgElement = document.getElementById(svgId);
                this.data = data;
                this.tooltip = document.getElementById('tooltip');
                this.paperTooltip = document.getElementById('paper-tooltip');
                this.width = 1600;
                this.height = 1000;
                this.nodeRadius = { 0: 40, 1: 30, 2: 25, 3: 20, 4: 15, 5: 20 };
                this.fontSize = { 0: '18px', 1: '16px', 2: '14px', 3: '12px', 4: '10px', 5: '9px' };
                this.init();
            }

            init() {
                // D3.jsでSVGを設定
                this.svg = d3.select(this.svgElement)
                    .attr('viewBox', `0 0 ${this.width} ${this.height}`);
                
                // ズーム機能を追加
                this.g = this.svg.append('g');
                
                // ズーム動作を定義
                this.zoom = d3.zoom()
                    .scaleExtent([0.5, 2])
                    .on('zoom', (event) => {
                        this.g.attr('transform', event.transform);
                    });
                
                // SVGにズーム動作を適用
                this.svg.call(this.zoom);
                
                // 初期ズームを少し縮小
                this.svg.call(this.zoom.transform, d3.zoomIdentity.scale(0.85));
                
                // グラデーション定義
                const defs = this.g.append('defs');
                
                // 背景のグラデーション
                const treeGradient = defs.append('radialGradient')
                    .attr('id', 'treeGradient')
                    .attr('cx', '50%')
                    .attr('cy', '100%')
                    .attr('r', '100%');
                
                treeGradient.append('stop')
                    .attr('offset', '0%')
                    .attr('stop-color', '#D4AF37')
                    .attr('stop-opacity', 0.1);
                
                treeGradient.append('stop')
                    .attr('offset', '50%')
                    .attr('stop-color', '#FFD700')
                    .attr('stop-opacity', 0.05);
                
                treeGradient.append('stop')
                    .attr('offset', '100%')
                    .attr('stop-color', '#B8860B')
                    .attr('stop-opacity', 0.02);
                
                // 地面のグラデーション
                const groundGradient = defs.append('linearGradient')
                    .attr('id', 'groundGradient')
                    .attr('x1', '0%').attr('y1', '0%')
                    .attr('x2', '0%').attr('y2', '100%');

                groundGradient.append('stop')
                    .attr('offset', '0%')
                    .attr('stop-color', '#654321')
                    .attr('stop-opacity', 0);
                groundGradient.append('stop')
                    .attr('offset', '70%')
                    .attr('stop-color', '#8B4513')
                    .attr('stop-opacity', 0.2);
                groundGradient.append('stop')
                    .attr('offset', '90%')
                    .attr('stop-color', '#654321')
                    .attr('stop-opacity', 0.4);

                // 根ノード用の特別なグラデーション
                const rootGradient = defs.append('radialGradient')
                    .attr('id', 'rootGradient');
                rootGradient.append('stop')
                    .attr('offset', '0%')
                    .attr('stop-color', '#FFD700')
                    .attr('stop-opacity', 1);
                rootGradient.append('stop')
                    .attr('offset', '60%')
                    .attr('stop-color', '#DAA520')
                    .attr('stop-opacity', 0.9);
                rootGradient.append('stop')
                    .attr('offset', '100%')
                    .attr('stop-color', '#8B4513')
                    .attr('stop-opacity', 0.8);

                // 枝のグラデーション（各枝ごとに作成）
                for (let i = 0; i < 50; i++) {
                    const branchGrad = defs.append('linearGradient')
                        .attr('id', `branchGradient${i}`)
                        .attr('x1', '0%').attr('y1', '0%')
                        .attr('x2', '100%').attr('y2', '100%');
                    
                    branchGrad.append('stop')
                        .attr('offset', '0%')
                        .attr('stop-color', '#8B4513')
                        .attr('stop-opacity', 0.9);
                    
                    branchGrad.append('stop')
                        .attr('offset', '100%')
                        .attr('stop-color', '#DAA520')
                        .attr('stop-opacity', 0.7);
                }

                // 金属的な質感を表現するフィルター
                const goldFilter = defs.append('filter')
                    .attr('id', 'goldLeaf')
                    .attr('x', '-50%')
                    .attr('y', '-50%')
                    .attr('width', '200%')
                    .attr('height', '200%');
                
                // 光沢効果
                goldFilter.append('feGaussianBlur')
                    .attr('in', 'SourceAlpha')
                    .attr('stdDeviation', '2')
                    .attr('result', 'blur');
                
                goldFilter.append('feSpecularLighting')
                    .attr('in', 'blur')
                    .attr('surfaceScale', '5')
                    .attr('specularConstant', '2')
                    .attr('specularExponent', '20')
                    .attr('lighting-color', '#ffd700')
                    .attr('result', 'specOut');
                
                goldFilter.append('feComposite')
                    .attr('in', 'specOut')
                    .attr('in2', 'SourceAlpha')
                    .attr('operator', 'in')
                    .attr('result', 'specOut2');
                
                goldFilter.append('feComposite')
                    .attr('in', 'SourceGraphic')
                    .attr('in2', 'specOut2')
                    .attr('operator', 'arithmetic')
                    .attr('k1', '0')
                    .attr('k2', '1')
                    .attr('k3', '1')
                    .attr('k4', '0');
                
                // ブロンズ効果フィルター
                const bronzeFilter = defs.append('filter')
                    .attr('id', 'bronze')
                    .attr('x', '-50%')
                    .attr('y', '-50%')
                    .attr('width', '200%')
                    .attr('height', '200%');
                
                bronzeFilter.append('feGaussianBlur')
                    .attr('in', 'SourceAlpha')
                    .attr('stdDeviation', '1.5')
                    .attr('result', 'blur');
                
                bronzeFilter.append('feSpecularLighting')
                    .attr('in', 'blur')
                    .attr('surfaceScale', '3')
                    .attr('specularConstant', '1.5')
                    .attr('specularExponent', '15')
                    .attr('lighting-color', '#cd7f32')
                    .attr('result', 'specOut');
                
                bronzeFilter.append('feComposite')
                    .attr('in', 'specOut')
                    .attr('in2', 'SourceAlpha')
                    .attr('operator', 'in')
                    .attr('result', 'specOut2');
                
                bronzeFilter.append('feComposite')
                    .attr('in', 'SourceGraphic')
                    .attr('in2', 'specOut2')
                    .attr('operator', 'arithmetic')
                    .attr('k1', '0')
                    .attr('k2', '1')
                    .attr('k3', '1')
                    .attr('k4', '0');

                // 装飾パターンを定義（クリムト風の渦巻き模様）
                const pattern = defs.append('pattern')
                    .attr('id', 'klimtPattern')
                    .attr('patternUnits', 'userSpaceOnUse')
                    .attr('width', 60)
                    .attr('height', 60);
                
                // 渦巻き模様（金色を控えめに）
                const spiralGroup = pattern.append('g');
                
                // 中心の円
                spiralGroup.append('circle')
                    .attr('cx', 30)
                    .attr('cy', 30)
                    .attr('r', 4)
                    .attr('fill', 'none')
                    .attr('stroke', '#d4af37')
                    .attr('stroke-width', 1)
                    .attr('opacity', 0.3);
                
                // 渦巻きパス
                const spiral = d3.path();
                const turns = 2;
                const pointsPerTurn = 30;
                for (let i = 0; i <= turns * pointsPerTurn; i++) {
                    const angle = (i / pointsPerTurn) * 2 * Math.PI;
                    const radius = 5 + (i / pointsPerTurn) * 10;
                    const x = 30 + Math.cos(angle) * radius;
                    const y = 30 + Math.sin(angle) * radius;
                    if (i === 0) {
                        spiral.moveTo(x, y);
                    } else {
                        spiral.lineTo(x, y);
                    }
                }
                
                spiralGroup.append('path')
                    .attr('d', spiral.toString())
                    .attr('fill', 'none')
                    .attr('stroke', '#b8860b')
                    .attr('stroke-width', 0.8)
                    .attr('opacity', 0.2);
                
                // 小さな円の装飾
                [15, 45].forEach(x => {
                    [15, 45].forEach(y => {
                        spiralGroup.append('circle')
                            .attr('cx', x)
                            .attr('cy', y)
                            .attr('r', 2)
                            .attr('fill', '#d4af37')
                            .attr('opacity', 0.2);
                    });
                });

                // 葉っぱの形状を定義
                defs.append('path')
                    .attr('id', 'leafShape')
                    .attr('d', 'M0,-15 Q-10,-5 -10,5 Q-10,15 0,20 Q10,15 10,5 Q10,-5 0,-15');

                // 背景レイヤー
                this.g.append('rect')
                    .attr('width', this.width)
                    .attr('height', this.height)
                    .attr('fill', '#fafafa')
                    .on('click', () => {
                        this.g.selectAll('.node-text').classed('fixed', false).classed('visible', false);
                    });
                
                // クリムトパターンを控えめに適用
                this.g.append('rect')
                    .attr('width', this.width)
                    .attr('height', this.height)
                    .attr('fill', 'url(#klimtPattern)')
                    .attr('opacity', 0.08)
                    .style('pointer-events', 'none');
                
                this.processData();
                this.createForceSimulation();
                this.setupControls();
            }

            processData() {
                const nodes = [];
                const links = [];
                let nodeId = 0;
                const height = this.height;
                const width = this.width;
                
                // ルートノード
                const root = {
                    id: nodeId++,
                    name: this.data.name,
                    description: this.data.description,
                    level: 0,
                    x: width / 2,
                    y: height - 100,
                    fx: width / 2,
                    fy: height - 100
                };
                nodes.push(root);

                // 再帰的にノードとリンクを作成
                const processChildren = (parent, children, level) => {
                    if (!children) return;
                    
                    children.forEach((child, i) => {
                        const node = {
                            id: nodeId++,
                            name: child.name,
                            description: child.description,
                            level: level,
                            papers: child.papers || []
                        };
                        
                        // レベルに応じて初期座標を設定
                        if (level === 1) {
                            node.x = width / 2 + (Math.random() - 0.5) * 200;
                            node.y = height - 250;
                        } else if (level === 2) {
                            node.x = width / 2 + (Math.random() - 0.5) * 400;
                            node.y = height - 500;
                        } else {
                            node.x = width / 2 + (Math.random() - 0.5) * 600;
                            node.y = height - 750;
                        }
                        
                        nodes.push(node);
                        
                        // リンクを作成
                        if (parent.level === 1 && child.papers && child.papers.length > 0) {
                            links.push({ source: parent.id, target: node.id, papers: child.papers });
                        } else {
                            links.push({ source: parent.id, target: node.id });
                        }
                        
                        // 子ノードを処理
                        if (child.children) {
                            processChildren(node, child.children, level + 1);
                        }
                        
                        // 論文ノードを追加
                        if (child.papers && child.papers.length > 0) {
                            const maxPapers = 5;
                            const papersToShow = Math.min(child.papers.length, maxPapers);
                            
                            child.papers.slice(0, papersToShow).forEach((paper, k) => {
                                const paperNode = {
                                    id: nodeId++,
                                    name: paper.year,
                                    description: paper.title,
                                    level: level + 1,
                                    paper: paper,
                                    x: node.x || width / 2,
                                    y: height - (200 + level * 150)
                                };
                                nodes.push(paperNode);
                                links.push({ source: node.id, target: paperNode.id });
                            });
                            
                            // 追加の論文ノード
                            if (child.papers.length > maxPapers) {
                                const moreNode = {
                                    id: nodeId++,
                                    name: `+${child.papers.length - maxPapers}`,
                                    description: `他${child.papers.length - maxPapers}件の論文`,
                                    level: level + 1,
                                    morePapers: child.papers.slice(maxPapers),
                                    x: node.x || width / 2,
                                    y: height - (200 + level * 150)
                                };
                                nodes.push(moreNode);
                                links.push({ source: node.id, target: moreNode.id });
                            }
                        }
                    });
                };

                processChildren(root, this.data.children, 1);
                
                this.nodes = nodes;
                this.links = links;
            }

            createForceSimulation() {
                // 年代による色を返す関数
                const getYearColor = (papers) => {
                    if (!papers || papers.length === 0) return '#666666';
                    
                    const latestYear = Math.max(...papers.map(p => parseInt(p.year) || 2010));
                    
                    if (latestYear >= 2023) return '#1e40af';
                    else if (latestYear >= 2019) return '#2563eb';
                    else if (latestYear >= 2016) return '#3b82f6';
                    else if (latestYear >= 2013) return '#60a5fa';
                    else return '#93c5fd';
                };
                
                // ノードの最新論文年を取得する関数
                const getLatestYear = (node) => {
                    if (node.paper) return parseInt(node.paper.year) || 2010;
                    if (node.papers && node.papers.length > 0) {
                        return Math.max(...node.papers.map(p => parseInt(p.year) || 2010));
                    }
                    let latestYear = 2010;
                    this.nodes.forEach(n => {
                        if (n.level === node.level + 1) {
                            const isChild = this.links.some(l => 
                                (l.source === node.id || l.source.id === node.id) && 
                                (l.target === n.id || l.target.id === n.id)
                            );
                            if (isChild) {
                                const childYear = getLatestYear(n);
                                latestYear = Math.max(latestYear, childYear);
                            }
                        }
                    });
                    return latestYear;
                };
                
                // 葉っぱの色を計算する関数（金色系）
                const getLeafColor = (year) => {
                    const yearNum = parseInt(year) || 2010;
                    const t = (yearNum - 2010) / 14; // 0-1に正規化
                    // 古い論文は茶色、新しい論文は明るい金色
                    return d3.interpolateRgb('#8b6914', '#d4af37')(t);
                };
                
                // ノードIDとインデックスのマップを作成
                this.nodeMap = {};
                this.nodes.forEach((node, i) => {
                    this.nodeMap[node.id] = i;
                });
                
                // 力学シミュレーションを作成
                this.simulation = d3.forceSimulation(this.nodes)
                    .force('link', d3.forceLink(this.links)
                        .id(d => d.id)
                        .distance(d => {
                            const sourceNode = typeof d.source === 'object' ? d.source : this.nodes.find(n => n.id === d.source);
                            const targetNode = typeof d.target === 'object' ? d.target : this.nodes.find(n => n.id === d.target);
                            if (!sourceNode || !targetNode) return 100;
                            
                            let baseDistance;
                            if (sourceNode.level === 0) baseDistance = 200;
                            else if (sourceNode.level === 1) baseDistance = 160;
                            else if (sourceNode.level === 2) baseDistance = 120;
                            else baseDistance = 80;
                            
                            return baseDistance * (0.5 + Math.random());
                        })
                        .strength(0.8))
                    .force('charge', d3.forceManyBody()
                        .strength(d => {
                            if (d.level === 0) return -3000;
                            if (d.level === 1) return -2500;
                            if (d.level === 2) return -2000;
                            if (d.level === 3) return -1500;
                            if (d.level === 4) return -1200;
                            return -1500;
                        }))
                    .force('x', d3.forceX(d => {
                        if (d.level === 0) return this.width / 2;
                        
                        if (d.paper) {
                            const year = parseInt(d.paper.year) || 2010;
                            const yearOffset = (year - 2010) / 14;
                            const spread = (Math.random() - 0.5) * 200 * (1 + yearOffset);
                            return this.width / 2 + spread;
                        }
                        
                        const latestYear = getLatestYear(d);
                        const yearOffset = (latestYear - 2010) / 14;
                        const spread = (Math.random() - 0.5) * 100 * yearOffset;
                        
                        return this.width / 2 + spread;
                    }).strength(0.1))
                    .force('y', d3.forceY(d => {
                        if (d.level === 0) return this.height - 100;
                        
                        if (d.paper) {
                            const year = parseInt(d.paper.year) || 2010;
                            const yearOffset = (year - 2010) / 14;
                            return this.height - 850 + (1 - yearOffset) * 100;
                        }
                        
                        const latestYear = getLatestYear(d);
                        const yearOffset = (latestYear - 2010) / 14;
                        
                        let baseY;
                        if (d.level === 1) baseY = this.height - 300;
                        else if (d.level === 2) baseY = this.height - 500;
                        else if (d.level === 3) baseY = this.height - 650;
                        else if (d.level === 4) baseY = this.height - 750;
                        else baseY = this.height - 850;
                        
                        return baseY - yearOffset * 150;
                    }).strength(0.7))
                    .force('collision', d3.forceCollide()
                        .radius(d => {
                            if (d.paper) return this.nodeRadius[d.level] + 60;
                            if (d.level >= 3) return this.nodeRadius[d.level] + 40;
                            return this.nodeRadius[d.level] + 30;
                        })
                        .strength(0.8));

                // リンクを描画
                const linkGroup = this.g.append('g').attr('class', 'links');
                const link = linkGroup.selectAll('path')
                    .data(this.links)
                    .enter().append('path')
                    .attr('class', 'link')
                    .attr('stroke', '#8B6914')  // より濃い茶色
                    .attr('stroke-width', d => {
                        const sourceNode = typeof d.source === 'object' ? d.source : this.nodes.find(n => n.id === d.source);
                        if (!sourceNode) return 2;
                        if (sourceNode.level === 0) return 12;  // 根からの幹は太く
                        if (sourceNode.level === 1) return 6;   // 主要な枝
                        if (sourceNode.level === 2) return 4;   // 小枝
                        return 2;  // 細い枝
                    })
                    .attr('fill', 'none')
                    .attr('opacity', d => {
                        const sourceNode = typeof d.source === 'object' ? d.source : this.nodes.find(n => n.id === d.source);
                        if (!sourceNode) return 0.6;
                        if (sourceNode.level === 0) return 0.9;  // 幹は濃く
                        return 0.7;
                    })
                    .attr('stroke-linecap', 'round')
                    .attr('stroke-linejoin', 'round');

                // ノードグループを作成
                const nodeGroup = this.g.append('g').attr('class', 'nodes');
                const node = nodeGroup.selectAll('g')
                    .data(this.nodes)
                    .enter().append('g')
                    .attr('class', 'node')
                    .style('cursor', 'pointer')
                    .call(d3.drag()
                        .on('start', (event, d) => this.dragstarted(event, d))
                        .on('drag', (event, d) => this.dragged(event, d))
                        .on('end', (event, d) => this.dragended(event, d)));

                // ノードの円を追加
                node.append('circle')
                    .attr('r', d => {
                        if (d.paper) return 16;
                        return this.nodeRadius[d.level] || 15;
                    })
                    .attr('class', d => `node-circle level-${d.level}`)
                    .attr('fill', d => {
                        if (d.paper && d.paper.year) {
                            return getYearColor([d.paper]);
                        }
                        if (d.morePapers && d.morePapers.length > 0) {
                            return getYearColor(d.morePapers);
                        }
                        if (d.papers && d.papers.length > 0) {
                            return getYearColor(d.papers);
                        }
                        // レベルごとの色（根は金色系、他はグレースケール）
                        if (d.level === 0) return '#b8860b';  // ダークゴールデンロッド
                        if (d.level === 1) return '#4b5563';
                        if (d.level === 2) return '#6b7280';
                        if (d.level === 3) return '#9ca3af';
                        return '#d1d5db';
                    })
                    .attr('stroke', d => {
                        if (d.paper) return '#e5e7eb';
                        if (d.level === 0) return '#d4af37';  // 根は金色の縁
                        return '#d1d5db';
                    })
                    .attr('stroke-width', d => {
                        if (d.level === 0) return 3;
                        return d.paper ? 1 : 2;
                    })
                    .style('filter', d => {
                        if (d.level === 0) return 'url(#goldLeaf)';  // 根ノードに金箔効果
                        if (d.level === 1) return 'url(#bronze)';     // 第1階層にブロンズ効果
                        return null;
                    });

                // 開花装飾を追加（レベル0-2のノードに）
                const flowerNodes = node.filter(d => d.level <= 2);
                
                flowerNodes.each(function(d) {
                    const flowerGroup = d3.select(this).append('g')
                        .attr('class', 'flower-decoration');
                    
                    // 花びらの数（レベルによって変化）
                    const petalCount = d.level === 0 ? 8 : (d.level === 1 ? 6 : 4);
                    const petalRadius = d.level === 0 ? 25 : (d.level === 1 ? 20 : 15);
                    
                    // 花びらを生成
                    for (let i = 0; i < petalCount; i++) {
                        const angle = (i / petalCount) * 2 * Math.PI;
                        const petalPath = d3.path();
                        
                        // 花びらの形を描画（ハート型の花びら）
                        petalPath.moveTo(0, 0);
                        petalPath.quadraticCurveTo(
                            -petalRadius * 0.5 * Math.cos(angle) - petalRadius * 0.2 * Math.sin(angle),
                            -petalRadius * 0.5 * Math.sin(angle) + petalRadius * 0.2 * Math.cos(angle),
                            -petalRadius * Math.cos(angle),
                            -petalRadius * Math.sin(angle)
                        );
                        petalPath.quadraticCurveTo(
                            -petalRadius * 0.5 * Math.cos(angle) + petalRadius * 0.2 * Math.sin(angle),
                            -petalRadius * 0.5 * Math.sin(angle) - petalRadius * 0.2 * Math.cos(angle),
                            0, 0
                        );
                        
                        flowerGroup.append('path')
                            .attr('d', petalPath.toString())
                            .attr('class', 'petal')
                            .attr('transform', `rotate(${(angle * 180 / Math.PI)})`)
                            .style('filter', d.level === 0 ? 'url(#goldLeaf)' : null)
                            .style('animation-delay', `${i * 0.1}s`);
                    }
                    
                    // 中心に小さな円（花の中心）
                    if (d.level === 0) {
                        flowerGroup.append('circle')
                            .attr('r', 5)
                            .attr('fill', '#ffd700')
                            .attr('opacity', 0.8)
                            .style('filter', 'url(#goldLeaf)');
                    }
                });
                
                // 装飾的な葉っぱをリンクの中間点付近に配置
                const leafGroup = this.g.append('g').attr('class', 'leaves');
                
                // 各リンクに対して葉っぱを配置（ランダムに選択）
                this.links.forEach((link, i) => {
                    // 30%の確率で葉っぱを配置
                    if (Math.random() < 0.3) {
                        const leafCount = Math.floor(Math.random() * 3) + 1; // 1-3枚の葉
                        
                        for (let j = 0; j < leafCount; j++) {
                            // リンクに沿った位置（20%-80%の範囲でランダム）
                            const t = 0.2 + Math.random() * 0.6;
                            
                            // オフセット（リンクから少し離れた位置）
                            const offsetAngle = Math.random() * Math.PI * 2;
                            const offsetDistance = 20 + Math.random() * 40;
                            
                            const leaf = leafGroup.append('g')
                                .attr('class', 'decorative-leaf')
                                .attr('opacity', 0.7 + Math.random() * 0.3);
                            
                            // 葉っぱの色（ランダムな年代風）
                            const randomYear = 2010 + Math.floor(Math.random() * 15);
                            const leafColor = getLeafColor(randomYear);
                            
                            leaf.append('path')
                                .attr('d', 'M0,-15 Q-8,-6 -8,6 Q-8,15 0,18 Q8,15 8,6 Q8,-6 0,-15')
                                .attr('fill', leafColor)
                                .attr('stroke', '#2F4F2F')
                                .attr('stroke-width', 0.8)
                                .attr('transform', `rotate(${Math.random() * 360})`)
                                .style('filter', 'drop-shadow(0 2px 3px rgba(0, 0, 0, 0.2))');
                            
                            // 葉っぱの位置を保存（シミュレーション時に更新）
                            leaf.node().__data__ = {
                                linkIndex: i,
                                t: t,
                                offsetAngle: offsetAngle,
                                offsetDistance: offsetDistance
                            };
                        }
                    }
                });

                // 葉っぱの色を控えめに
                
                // 論文ノードに結晶装飾を追加
                const paperNodes = node.filter(d => d.paper);
                
                paperNodes.each(function(d) {
                    const crystalGroup = d3.select(this).append('g')
                        .attr('class', 'flower-decoration');
                    
                    // 結晶の形（8方向の針状）
                    const crystalSize = 12;
                    for (let i = 0; i < 8; i++) {
                        const angle = (i / 8) * 2 * Math.PI;
                        const length = i % 2 === 0 ? crystalSize : crystalSize * 0.7;
                        
                        crystalGroup.append('line')
                            .attr('x1', 0)
                            .attr('y1', 0)
                            .attr('x2', Math.cos(angle) * length)
                            .attr('y2', Math.sin(angle) * length)
                            .attr('stroke', getYearColor([d.paper]))
                            .attr('stroke-width', 2)
                            .attr('opacity', 0.6);
                    }
                    
                    // 中心の小さな円
                    crystalGroup.append('circle')
                        .attr('r', 3)
                        .attr('fill', getYearColor([d.paper]))
                        .attr('opacity', 0.8);
                });

                // ノードのテキストを追加（縁取り付き）
                node.append('text')
                    .attr('class', 'node-text')
                    .attr('fill', 'black')
                    .attr('font-size', d => this.fontSize[d.level])
                    .attr('text-anchor', 'middle')
                    .attr('dominant-baseline', 'central')
                    .attr('stroke', '#ffffff')
                    .attr('stroke-width', '4px')
                    .attr('paint-order', 'stroke')
                    .attr('font-weight', d => {
                        if (d.level === 0) return '800';
                        if (d.level === 1) return '700';
                        if (d.level === 2) return '600';
                        if (d.level === 3) return '500';
                        return '400';
                    })
                    .text(d => d.name);
                
                // 前面のテキスト（黒色）
                node.append('text')
                    .attr('class', 'node-text')
                    .attr('fill', '#000000')
                    .attr('font-size', d => this.fontSize[d.level])
                    .attr('text-anchor', 'middle')
                    .attr('dominant-baseline', 'central')
                    .attr('font-weight', d => {
                        if (d.level === 0) return '800';
                        if (d.level === 1) return '700';
                        if (d.level === 2) return '600';
                        if (d.level === 3) return '500';
                        return '400';
                    })
                    .text(d => d.name);

                // ホバーイベントとクリックイベント
                node.on('mouseenter', (event, d) => {
                    this.showTooltip(event, d);
                    const nodeElement = d3.select(event.currentTarget);
                    nodeElement.selectAll('.node-text').each(function() {
                        if (!d3.select(this).classed('fixed')) {
                            d3.select(this).classed('visible', true);
                        }
                    });
                })
                .on('mouseleave', (event, d) => {
                    this.hideTooltip();
                    const nodeElement = d3.select(event.currentTarget);
                    nodeElement.selectAll('.node-text').each(function() {
                        if (!d3.select(this).classed('fixed')) {
                            d3.select(this).classed('visible', false);
                        }
                    });
                })
                .on('mousemove', (event) => this.updateTooltipPosition(event))
                .on('click', (event, d) => {
                    event.stopPropagation();
                    const nodeElement = d3.select(event.currentTarget);
                    nodeElement.selectAll('.node-text').each(function() {
                        const isFixed = d3.select(this).classed('fixed');
                        d3.select(this).classed('fixed', !isFixed);
                        if (!isFixed) {
                            d3.select(this).classed('visible', true);
                        }
                    });
                });

                // 論文がある枝にインジケーターを追加
                const paperIndicators = linkGroup.selectAll('.paper-indicator')
                    .data(this.links.filter(d => d.papers && d.papers.length > 0))
                    .enter().append('g')
                    .attr('class', 'paper-indicator-group');

                paperIndicators.append('circle')
                    .attr('r', 6)
                    .attr('fill', '#2563eb')
                    .attr('class', 'paper-indicator')
                    .on('mouseenter', (event, d) => {
                        const targetNode = typeof d.target === 'object' ? d.target : this.nodes.find(n => n.id === d.target);
                        if (targetNode) {
                            this.showPaperTooltip(event, d.papers, targetNode.name);
                        }
                    })
                    .on('mouseleave', () => this.hidePaperTooltip())
                    .on('mousemove', (event) => this.updatePaperTooltipPosition(event));

                paperIndicators.append('text')
                    .attr('fill', '#000000')
                    .attr('font-size', '10px')
                    .attr('font-weight', 'bold')
                    .attr('text-anchor', 'middle')
                    .attr('dominant-baseline', 'central')
                    .attr('pointer-events', 'none')
                    .attr('stroke', '#ffffff')
                    .attr('stroke-width', '2px')
                    .attr('paint-order', 'stroke')
                    .text(d => d.papers.length);

                // シミュレーションのティック処理
                this.simulation.on('tick', () => {
                    // リンクをより自然な曲線で描画
                    link.attr('d', d => {
                        const source = d.source;
                        const target = d.target;
                        if (!source || !target) return '';
                        
                        // ターゲットが論文ノードの場合、論文ノードを中心とした渦巻きを描く
                        if (target.paper && source.level >= 2) {
                            const centerX = target.x;
                            const centerY = target.y;
                            
                            const dx = centerX - source.x;
                            const dy = centerY - source.y;
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            const angle = Math.atan2(dy, dx);
                            
                            const spirals = 2;
                            const maxRadius = Math.min(distance * 0.7, 80);
                            const minRadius = 25;
                            const points = [];
                            const steps = 60;
                            
                            points.push([source.x, source.y]);
                            
                            const connectionLength = distance * 0.3;
                            for (let i = 1; i <= 10; i++) {
                                const t = i / 10;
                                const x = source.x + dx * t * 0.3;
                                const y = source.y + dy * t * 0.3;
                                points.push([x, y]);
                            }
                            
                            for (let i = 0; i <= steps; i++) {
                                const t = i / steps;
                                const spiralAngle = angle + spirals * 2 * Math.PI * t;
                                const r = maxRadius * (1 - t * 0.8) + minRadius * (t * 0.8);
                                
                                const x = centerX - r * Math.cos(spiralAngle);
                                const y = centerY - r * Math.sin(spiralAngle);
                                
                                points.push([x, y]);
                            }
                            
                            const line = d3.line().curve(d3.curveBasis);
                            return line(points);
                        } else {
                            // 通常の自然な曲線
                            const dx = target.x - source.x;
                            const dy = target.y - source.y;
                            const dr = Math.sqrt(dx * dx + dy * dy);
                            
                            // 枝の「たわみ」を追加
                            const sweep = Math.random() * 0.3 + 0.2;
                            const controlPoint1X = source.x + dx * 0.25 + dy * sweep;
                            const controlPoint1Y = source.y + dy * 0.25 - dx * sweep;
                            const controlPoint2X = source.x + dx * 0.75 - dy * sweep * 0.5;
                            const controlPoint2Y = source.y + dy * 0.75 + dx * sweep * 0.5;
                            
                            return `M${source.x},${source.y} C${controlPoint1X},${controlPoint1Y} ${controlPoint2X},${controlPoint2Y} ${target.x},${target.y}`;
                        }
                    });

                    // ノードの位置を更新
                    node.attr('transform', d => `translate(${d.x}, ${d.y})`);

                    // 論文インジケーターの位置を更新
                    paperIndicators.attr('transform', d => {
                        if (!d.source || !d.target) return '';
                        const midX = (d.source.x + d.target.x) / 2;
                        const midY = (d.source.y + d.target.y) / 2;
                        return `translate(${midX}, ${midY})`;
                    });
                    
                    // 装飾的な葉っぱの位置を更新
                    const linksData = this.links;
                    leafGroup.selectAll('.decorative-leaf').attr('transform', function(d) {
                        const leafData = this.__data__;
                        if (!leafData) return '';
                        
                        const link = linksData[leafData.linkIndex];
                        if (!link.source || !link.target) return '';
                        
                        // リンクの中間点を計算
                        const sourceX = link.source.x;
                        const sourceY = link.source.y;
                        const targetX = link.target.x;
                        const targetY = link.target.y;
                        
                        // t の位置を計算
                        const x = sourceX + (targetX - sourceX) * leafData.t;
                        const y = sourceY + (targetY - sourceY) * leafData.t;
                        
                        // オフセットを適用
                        const offsetX = x + Math.cos(leafData.offsetAngle) * leafData.offsetDistance;
                        const offsetY = y + Math.sin(leafData.offsetAngle) * leafData.offsetDistance;
                        
                        return `translate(${offsetX}, ${offsetY})`;
                    });
                });

                this.link = link;
                this.node = node;
                this.paperIndicators = paperIndicators;
                this.leafGroup = leafGroup;
            }

            dragstarted(event, d) {
                if (!event.active) this.simulation.alphaTarget(0.3).restart();
                d.fx = d.x;
                d.fy = d.y;
            }

            dragged(event, d) {
                d.fx = event.x;
                d.fy = event.y;
            }

            dragended(event, d) {
                if (!event.active) this.simulation.alphaTarget(0);
                if (d.level !== 0) {
                    d.fx = null;
                    d.fy = null;
                }
            }

            setupControls() {
                document.getElementById('restart-simulation').addEventListener('click', () => {
                    this.nodes.forEach(d => {
                        if (d.level !== 0) {
                            d.fx = null;
                            d.fy = null;
                        }
                    });
                    this.simulation.alpha(1).restart();
                });

                document.getElementById('freeze-simulation').addEventListener('click', () => {
                    this.nodes.forEach(d => {
                        d.fx = d.x;
                        d.fy = d.y;
                    });
                });

                document.getElementById('reset-zoom').addEventListener('click', () => {
                    this.svg.transition()
                        .duration(750)
                        .call(this.zoom.transform, d3.zoomIdentity.scale(0.85));
                });
            }

            showTooltip(event, node) {
                let content = `<strong>${node.name}</strong><br>${node.description}`;
                if (node.paper) {
                    content = `<strong>${node.paper.title}</strong><br>${node.paper.journal} ${node.paper.year}<br>${node.paper.details}`;
                } else if (node.morePapers) {
                    content = `<strong>追加の論文</strong><br>`;
                    node.morePapers.forEach(paper => {
                        content += `・${paper.title}<br>`;
                    });
                }
                this.tooltip.innerHTML = content;
                this.tooltip.classList.add('visible');
                this.updateTooltipPosition(event);
            }

            hideTooltip() {
                this.tooltip.classList.remove('visible');
            }

            updateTooltipPosition(event) {
                this.tooltip.style.left = `${event.clientX + 10}px`;
                this.tooltip.style.top = `${event.clientY - 10}px`;
            }

            showPaperTooltip(event, papers, categoryName) {
                let html = `<h4>📚 ${categoryName} の論文一覧 <span class="paper-count">${papers.length}</span></h4>`;
                
                papers.forEach(paper => {
                    html += `
                        <div class="paper-item">
                            <div class="paper-title">${paper.title}</div>
                            <div class="paper-meta">
                                ${paper.journal} ${paper.year} ${paper.details}
                            </div>
                        </div>
                    `;
                });
                
                this.paperTooltip.innerHTML = html;
                this.paperTooltip.classList.add('visible');
                this.updatePaperTooltipPosition(event);
            }

            hidePaperTooltip() {
                this.paperTooltip.classList.remove('visible');
            }

            updatePaperTooltipPosition(event) {
                const tooltipRect = this.paperTooltip.getBoundingClientRect();
                const windowWidth = window.innerWidth;
                const windowHeight = window.innerHeight;
                
                let left = event.clientX + 15;
                let top = event.clientY - 15;
                
                if (left + tooltipRect.width > windowWidth) {
                    left = event.clientX - tooltipRect.width - 15;
                }
                
                if (top + tooltipRect.height > windowHeight) {
                    top = windowHeight - tooltipRect.height - 10;
                }
                
                this.paperTooltip.style.left = `${left}px`;
                this.paperTooltip.style.top = `${top}px`;
            }
        }

        // ページ読み込み完了時に系統樹を作成
        document.addEventListener('DOMContentLoaded', function() {
            new TreeChart('tree-chart', treeData);
        });
    </script>
</body>
</html>
