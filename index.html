<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å°é‡åŸå½©é¦™ã®ç ”ç©¶ç³»çµ±æ¨¹ - Enhanced Visual</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@300;400;500;600&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=Sawarabi+Mincho&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=Shippori+Mincho:wght@400;500;600;700;800&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=Klee+One:wght@400;600&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: "Shippori Mincho", "Sawarabi Mincho", "ãƒ’ãƒ©ã‚®ãƒæ˜æœ Pro", "Hiragino Mincho Pro", serif;
            background: #f5f5f5;
            min-height: 100vh;
            color: #333333;
            position: relative;
            overflow-x: hidden;
        }
        
        @keyframes subtle-fade {
            0%, 100% { opacity: 0.8; }
            50% { opacity: 1; }
        }
        
        @keyframes metallic-shimmer {
            0% { filter: url(#goldLeaf) brightness(1); }
            50% { filter: url(#goldLeaf) brightness(1.3); }
            100% { filter: url(#goldLeaf) brightness(1); }
        }
        
        @keyframes petal-wave {
            0% { transform: scale(1) rotate(0deg); }
            50% { transform: scale(1.1) rotate(5deg); }
            100% { transform: scale(1) rotate(0deg); }
        }
        
        .node-circle.level-0 {
            animation: metallic-shimmer 4s ease-in-out infinite;
        }
        
        .node:hover .petal {
            animation: petal-wave 0.8s ease-in-out;
            animation-delay: calc(var(--petal-index) * 0.1s);
        }

        .container {
            max-width: 1800px;
            margin: 0 auto;
            padding: 30px 20px;
        }

        .main-title {
            text-align: center;
            margin-bottom: 40px;
            background: #ffffff;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            position: relative;
        }

        .main-title h1 {
            font-family: "Klee One", "Shippori Mincho", "ãƒ’ãƒ©ã‚®ãƒæ˜æœ Pro", serif;
            font-size: 2.8em;
            color: #333333;
            font-weight: 600;
            margin-bottom: 15px;
            letter-spacing: 0.05em;
            position: relative;
        }

        .main-title h1::after {
            content: '';
            position: absolute;
            bottom: -8px;
            left: 50%;
            transform: translateX(-50%);
            width: 100px;
            height: 3px;
            background: linear-gradient(90deg, transparent, #d4af37, transparent);
        }

        .subtitle {
            font-family: "Sawarabi Mincho", "ãƒ’ãƒ©ã‚®ãƒæ˜æœ Pro", serif;
            font-size: 1.1em;
            color: #666666;
            font-weight: 400;
            letter-spacing: 0.03em;
        }

        .chart-container {
            background: #ffffff;
            border-radius: 12px;
            padding: 30px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            margin-bottom: 30px;
            overflow-x: auto;
            position: relative;
        }

        .tree-svg {
            width: 100%;
            height: 1000px;
            min-width: 1600px;
            cursor: move;
        }
        
        .svg-container {
            width: 100%;
            overflow-x: auto;
            overflow-y: hidden;
        }

        .node {
            cursor: pointer;
        }

        .node-circle {
            transition: all 0.3s ease;
        }

        .node:hover .node-circle {
            stroke-width: 3;
            transform: scale(1.1);
        }

        /* é–‹èŠ±åŠ¹æœã®ãŸã‚ã®è£…é£¾è¦ç´  */
        .flower-decoration {
            opacity: 0;
            transform: scale(0) rotate(0deg);
            transition: all 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            transform-origin: center;
        }

        .node:hover .flower-decoration {
            opacity: 1;
            transform: scale(1) rotate(180deg);
        }

        .petal {
            fill: #d4af37;
            opacity: 0.6;
            mix-blend-mode: multiply;
        }

        .node-text {
            font-family: "Shippori Mincho", "Sawarabi Mincho", "ãƒ’ãƒ©ã‚®ãƒæ˜æœ Pro", serif;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        .node-text.visible {
            opacity: 1;
        }
        
        .node-text.fixed {
            opacity: 1 !important;
        }

        .link {
            fill: none;
            transition: all 0.3s ease;
        }

        .link:hover {
            opacity: 0.8;
        }

        .paper-indicator {
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .paper-indicator:hover {
            transform: scale(1.2);
        }

        .paper-tooltip {
            position: absolute;
            background: #ffffff;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            padding: 20px;
            font-size: 0.85em;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease;
            z-index: 1001;
            max-width: 500px;
            min-width: 300px;
            max-height: 600px;
            overflow-y: auto;
        }

        .paper-tooltip.visible {
            opacity: 1;
        }

        .paper-tooltip h4 {
            color: #333333;
            font-size: 1.1em;
            margin-bottom: 15px;
            font-weight: 600;
            border-bottom: 2px solid #2563eb;
            padding-bottom: 8px;
        }

        .paper-item {
            margin-bottom: 12px;
            padding: 8px 12px;
            background: #f8f8f8;
            border-radius: 6px;
            border-left: 3px solid #2563eb;
        }

        .paper-title {
            font-weight: 600;
            color: #333333;
            margin-bottom: 4px;
            line-height: 1.3;
            font-size: 0.9em;
        }

        .paper-meta {
            color: #666666;
            font-size: 0.85em;
            font-style: italic;
        }

        .paper-count {
            background: #2563eb;
            color: #ffffff;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 0.8em;
            font-weight: 600;
        }

        .tooltip {
            position: absolute;
            background: #ffffff;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            padding: 12px;
            font-size: 0.9em;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease;
            z-index: 1000;
            max-width: 300px;
            color: #333333;
        }

        .tooltip.visible {
            opacity: 1;
        }

        .chart-note {
            text-align: center;
            color: #666666;
            font-size: 0.9em;
            margin-top: 20px;
            padding: 15px;
            background: #f8f8f8;
            border-radius: 8px;
        }

        .info-section {
            background: #ffffff;
            border-radius: 12px;
            padding: 30px;
            margin: 30px 0;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        .info-section h3 {
            color: #333333;
            font-size: 1.8em;
            margin-bottom: 20px;
            text-align: center;
            font-weight: 600;
        }

        .timeline-items {
            display: grid;
            gap: 15px;
        }

        .timeline-item {
            background: #f8f8f8;
            border-radius: 8px;
            padding: 20px;
            border-left: 4px solid #2563eb;
            transition: all 0.3s ease;
            color: #333333;
        }

        .timeline-item:hover {
            transform: translateX(5px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
        }

        .year {
            font-weight: 600;
            color: #2563eb;
            font-size: 1.1em;
        }

        .legend {
            position: absolute;
            bottom: 60px;
            left: 300px;
            background: #ffffff;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            padding: 15px;
            font-size: 0.85em;
            z-index: 10;
            color: #333333;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
            font-size: 0.8em;
            color: #333333;
        }

        .legend-item:last-child {
            margin-bottom: 0;
        }

        .legend-circle {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            margin-right: 8px;
            flex-shrink: 0;
        }

        .controls {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: #ffffff;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            padding: 15px;
            font-size: 0.85em;
            z-index: 10;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .controls button {
            background: #2563eb;
            color: #ffffff;
            border: none;
            border-radius: 6px;
            padding: 8px 16px;
            margin: 0 5px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.85em;
        }

        .controls button:hover {
            background: #1d4ed8;
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        @media (max-width: 768px) {
            .container {
                padding: 20px 15px;
            }
            
            .main-title h1 {
                font-size: 2.2em;
            }
            
            .tree-svg {
                height: 700px;
            }
            
            .main-title {
                padding: 20px;
            }
            
            .chart-container {
                padding: 20px;
            }
            
            .legend {
                position: static;
                margin-bottom: 20px;
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="main-title">
            <h1>ğŸŒ³ å°é‡åŸå½©é¦™ã®ç ”ç©¶ç³»çµ±æ¨¹</h1>
            <div class="subtitle">æ ¹ã‹ã‚‰å¹¹ã€æã‚’çµŒã¦è‘‰ã¸ã¨æˆé•·ã™ã‚‹ç ”ç©¶ã®ç³»çµ±ç™ºç”Ÿ - åŠ›å­¦çš„é…ç½®ã«ã‚ˆã‚Šè‡ªç„¶ã«åºƒãŒã‚‹çŸ¥è­˜ã®æ¨¹</div>
            <p><a href="https://en.wikipedia.org/wiki/The_Tree_of_Life,_Stoclet_Frieze">ã‚¯ãƒªãƒ ãƒˆã®ç”Ÿå‘½ã®æ¨¹</a>ã€<a href="[https://tarabooks.com/shop/the-night-life-of-trees/]">å¤œã®æœ¨</a>ã€<a href="[https://ja.wikipedia.org/wiki/%E3%83%A2%E3%83%81%E3%83%A2%E3%83%81%E3%81%AE%E6%9C%A8]">ãƒ¢ãƒãƒ¢ãƒã®æ¨¹</a>ãªã©ã‚’ã‚¤ãƒ¡ãƒ¼ã‚¸ã—ã¦ä½œæˆã—ã¦ã„ã¾ã™ã€‚</p>
        </div>
        
        <div class="chart-container">
            <div class="legend">
                <div class="legend-item">
                    <div class="legend-circle" style="background: #b8860b;"></div>
                    <span>æ ¹ï¼ˆç ”ç©¶è€…ï¼‰</span>
                </div>
                <div class="legend-item">
                    <svg width="40" height="16" style="vertical-align: middle; margin-right: 8px;">
                        <line x1="0" y1="8" x2="40" y2="8" stroke="#8B6914" stroke-width="4" stroke-linecap="round"/>
                    </svg>
                    <span>å¹¹ãƒ»æ</span>
                </div>
                <div class="legend-item" style="margin-top: 10px; padding-top: 10px; border-top: 1px solid #e0e0e0;">
                    <span style="color: #666666;">è«–æ–‡ãƒãƒ¼ãƒ‰ï¼šå¹´ä»£åˆ¥ã®è‰²</span>
                </div>
                <div class="legend-item">
                    <div class="legend-circle" style="background: #93c5fd;"></div>
                    <span style="font-size: 0.7em;">2010-2012å¹´</span>
                </div>
                <div class="legend-item">
                    <div class="legend-circle" style="background: #60a5fa;"></div>
                    <span style="font-size: 0.7em;">2013-2015å¹´</span>
                </div>
                <div class="legend-item">
                    <div class="legend-circle" style="background: #3b82f6;"></div>
                    <span style="font-size: 0.7em;">2016-2018å¹´</span>
                </div>
                <div class="legend-item">
                    <div class="legend-circle" style="background: #2563eb;"></div>
                    <span style="font-size: 0.7em;">2019-2022å¹´</span>
                </div>
                <div class="legend-item">
                    <div class="legend-circle" style="background: #1e40af;"></div>
                    <span style="font-size: 0.7em;">2023-2024å¹´</span>
                </div>
                <div class="legend-item" style="margin-top: 10px; padding-top: 10px; border-top: 1px solid rgba(255,255,255,0.3);">
                    <span style="font-size: 0.7em; color: #FFD700;">ğŸƒ è‘‰ã£ã±ï¼šè«–æ–‡</span>
                </div>
                <div class="legend-item" style="margin-top: 10px; padding-top: 10px; border-top: 1px solid rgba(255,255,255,0.3);">
                    <span style="font-size: 0.7em; color: #FFD700;">æ“ä½œæ–¹æ³•</span>
                </div>
                <div class="legend-item">
                    <span style="font-size: 0.7em;">ãƒ»ãƒãƒ¼ãƒ‰ã‚’ãƒ›ãƒãƒ¼ï¼šãƒ†ã‚­ã‚¹ãƒˆè¡¨ç¤º</span>
                </div>
                <div class="legend-item">
                    <span style="font-size: 0.7em;">ãƒ»ãƒãƒ¼ãƒ‰ã‚’ã‚¯ãƒªãƒƒã‚¯ï¼šè¡¨ç¤ºå›ºå®š</span>
                </div>
                <div class="legend-item">
                    <span style="font-size: 0.7em;">ãƒ»èƒŒæ™¯ã‚’ã‚¯ãƒªãƒƒã‚¯ï¼šå…¨è§£é™¤</span>
                </div>
            </div>
            <div class="controls">
                <button id="restart-simulation">é…ç½®ã‚’ãƒªã‚»ãƒƒãƒˆ</button>
                <button id="freeze-simulation">é…ç½®ã‚’å›ºå®š</button>
                <button id="reset-zoom">è¡¨ç¤ºã‚’ãƒªã‚»ãƒƒãƒˆ</button>
            </div>
            <svg class="tree-svg" id="tree-chart"></svg>
            <div class="chart-note">
                ğŸŒ³ åŠ›å­¦çš„é…ç½®ã«ã‚ˆã‚Šè‡ªç„¶ã«åºƒãŒã‚‹ç ”ç©¶ç³»çµ±æ¨¹<br>
                ğŸ” ãƒãƒ¼ãƒ‰ã‚’ãƒ‰ãƒ©ãƒƒã‚°ã—ã¦é…ç½®ã‚’èª¿æ•´ã§ãã¾ã™<br>
                ğŸ“ ãƒãƒ¼ãƒ‰ã«ãƒã‚¦ã‚¹ã‚’é‡ã­ã‚‹ã¨ãƒ†ã‚­ã‚¹ãƒˆãŒè¡¨ç¤ºã•ã‚Œã€ã‚¯ãƒªãƒƒã‚¯ã§è¡¨ç¤ºã‚’å›ºå®šã§ãã¾ã™<br>
                ğŸƒ è‘‰ã£ã±ã¯è«–æ–‡ã‚’è¡¨ã—ã€æ–°ã—ã„ç ”ç©¶ã»ã©é®®ã‚„ã‹ãªç·‘è‰²ã«ãªã‚Šã¾ã™
            </div>
        </div>

        <div class="info-section">
            <h3>ğŸ“… ç ”ç©¶ç™ºå±•ã®æ™‚ç³»åˆ—</h3>
            <div class="timeline-items">
                <div class="timeline-item">
                    <span class="year">2024å¹´:</span> å¯¾è©±å‹AIãƒ¢ãƒ‡ãƒ«ã¨éŸ³å£°æŠ€è¡“ã®æ•™è‚²å¿œç”¨
                </div>
                <div class="timeline-item">
                    <span class="year">2023å¹´:</span> ãƒ™ã‚¤ã‚¸ã‚¢ãƒ³ç³»çµ±ç™ºç”Ÿè§£æè«–æ–‡ (Journal of Language Evolution)
                </div>
                <div class="timeline-item">
                    <span class="year">2022å¹´:</span> é€²åŒ–çš„ã‚¢ãƒ—ãƒ­ãƒ¼ãƒã«ã‚ˆã‚‹ã‚¢ã‚¯ã‚»ãƒ³ãƒˆæ©Ÿèƒ½ç ”ç©¶é–‹å§‹
                </div>
                <div class="timeline-item">
                    <span class="year">2018-2023å¹´:</span> é›†å›£æ§‹é€ ã‚’è€ƒæ…®ã—ãŸè¨€èªå¤‰åŒ–ãƒ—ãƒ­ã‚»ã‚¹ç ”ç©¶
                </div>
                <div class="timeline-item">
                    <span class="year">2016-2019å¹´:</span> è¨€èªå¤‰åŒ–è¦å› ã¨ç³»è­œã®å®šé‡çš„è©•ä¾¡ç ”ç©¶
                </div>
                <div class="timeline-item">
                    <span class="year">2013-2017å¹´:</span> æ•°ç†çš„ã‚¢ãƒ—ãƒ­ãƒ¼ãƒã«ã‚ˆã‚‹è¨€èªå‹•æ…‹ç ”ç©¶ï¼ˆåšå£«ç ”ç©¶ï¼‰
                </div>
                <div class="timeline-item">
                    <span class="year">2010-2013å¹´:</span> æ–¹è¨€åˆ†å¸ƒãƒ»æ–‡åŒ–é ˜åŸŸåˆ†æã®åŸºç¤ç ”ç©¶
                </div>
            </div>
        </div>
    </div>

    <div class="tooltip" id="tooltip"></div>
    <div class="paper-tooltip" id="paper-tooltip"></div>

    <script>
        // ç ”ç©¶ãƒ‡ãƒ¼ã‚¿ï¼ˆè«–æ–‡æƒ…å ±ä»˜ãï¼‰
        const treeData = {
            name: 'å°é‡åŸå½©é¦™',
            description: 'è¨€èªå­¦ãƒ»æ–‡åŒ–é€²åŒ–ãƒ»ãƒ‡ãƒ¼ã‚¿ã‚µã‚¤ã‚¨ãƒ³ã‚¹ç ”ç©¶è€…',
            level: 0,
            children: [
                {
                    name: 'æ–‡åŒ–é€²åŒ–ç†è«–',
                    description: 'æ–‡åŒ–ä¼é”ãƒ¢ãƒ‡ãƒ«ãƒ»å®šé‡åˆ†æ',
                    level: 1,
                    children: [
                        {
                            name: 'è¨€èªé€²åŒ–ç ”ç©¶',
                            description: 'ãƒ™ã‚¤ã‚¸ã‚¢ãƒ³ç³»çµ±ç™ºç”Ÿè§£æãƒ»ã‚¢ã‚¯ã‚»ãƒ³ãƒˆç ”ç©¶',
                            level: 2,
                            children: [
                                { 
                                    name: 'ã‚¢ã‚¯ã‚»ãƒ³ãƒˆç³»çµ±ç™ºç”Ÿå­¦', 
                                    description: 'ãƒ™ã‚¤ã‚¸ã‚¢ãƒ³ç³»çµ±ç™ºç”Ÿè§£æã«ã‚ˆã‚‹ãƒ”ãƒƒãƒã‚¢ã‚¯ã‚»ãƒ³ãƒˆã‚·ã‚¹ãƒ†ãƒ ', 
                                    level: 3,
                                    papers: [
                                        {
                                            title: 'Bayesian phylogenetic analysis of pitch-accent systems based on accentual class merger: a new method applied to Japanese dialects',
                                            journal: 'Journal of Language Evolution',
                                            year: '2024',
                                            details: '8(2) 169-191, æŸ»èª­æœ‰ã‚Š'
                                        },
                                        {
                                            title: 'Inferring the temporal and spatial evolution of accent systems in Japanese dialects: a phylogeographic approach',
                                            journal: 'Proceedings of the Joint Conference on Language Evolution',
                                            year: '2022',
                                            details: 'æŸ»èª­æœ‰ã‚Š'
                                        }
                                    ]
                                },
                                { 
                                    name: 'æ–¹è¨€ã®æ™‚ç©ºé–“å¤‰ç•°', 
                                    description: 'æ—¥æœ¬èªæ–¹è¨€ã®ã‚¢ã‚¯ã‚»ãƒ³ãƒˆã‚·ã‚¹ãƒ†ãƒ ã®æ™‚ç©ºé–“é€²åŒ–', 
                                    level: 3,
                                    papers: [
                                        {
                                            title: 'è¨€èªã®æ¶ˆå¤±ã¨ç²å¾—ã«é–¢é€£ã™ã‚‹ç’°å¢ƒãƒ»ç¤¾ä¼šçš„è¦å› ',
                                            journal: 'GISï¼ç†è«–ã¨å¿œç”¨',
                                            year: '2016',
                                            details: '24(2), æ‹›å¾…æœ‰ã‚Š'
                                        },
                                        {
                                            title: 'æ—¥æœ¬èªæ–¹è¨€ã®æ¨å®šã•ã‚ŒãŸã‚¢ã‚¯ã‚»ãƒ³ãƒˆé¡åˆ¥ã®ä½µåˆç‡ã®ç³»çµ±åœ°ç†',
                                            journal: 'GISï¼ç†è«–ã¨å¿œç”¨',
                                            year: '2016',
                                            details: '24(2), æ‹›å¾…æœ‰ã‚Š'
                                        },
                                        {
                                            title: 'ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ä¸Šã®æ–‡åŒ–ä¼é”ãƒ¢ãƒ‡ãƒ«ã«ã‚ˆã‚‹æ—¥æœ¬èªã‚¢ã‚¯ã‚»ãƒ³ãƒˆæ§˜å¼ã®å¤‰ç•°ç‡ãƒ»ç³»çµ±é–¢ä¿‚ã®æ¨å®š',
                                            journal: 'å›½ç«‹å›½èªç ”ç©¶æ‰€ æ™‚ç©ºé–“å¤‰ç•°ç ”ç©¶ç³» åˆåŒç ”ç©¶ç™ºè¡¨ä¼š JLVC2012 äºˆç¨¿é›†',
                                            year: '2012',
                                            details: '43-46, æŸ»èª­æœ‰ã‚Š'
                                        }
                                    ]
                                },
                                { 
                                    name: 'è¨€èªå¤‰åŒ–ãƒ¢ãƒ‡ãƒ«', 
                                    description: 'æ•°ç†çš„ã‚¢ãƒ—ãƒ­ãƒ¼ãƒã«ã‚ˆã‚‹è¨€èªå‹•æ…‹', 
                                    level: 3,
                                    papers: [
                                        {
                                            title: 'æ•°ç†çš„ã‚¢ãƒ—ãƒ­ãƒ¼ãƒã‹ã‚‰ã®è¨€èªå¤‰åŒ–ã¨å¤–è¨€èªçš„è¦ç´ ã¨ã®é–¢ã‚ã‚Šã«é–¢ã™ã‚‹ç ”ç©¶',
                                            journal: '',
                                            year: '2014',
                                            details: 'æŸ»èª­æœ‰ã‚Šç­†é ­è‘—è€…'
                                        },
                                        {
                                            title: 'äº¤é€šç³»çµ±è¨ˆæƒ…å ±ã®åˆ†å¸ƒã¨è¨€èªå¤–çš„è¦ç´ ã«é–¢ã™ã‚‹ç ”ç©¶',
                                            journal: 'æƒ…å ±å‡¦ç†å­¦ä¼šã‚·ãƒ³ãƒã‚¸ã‚¦ãƒ è«–æ–‡é›†',
                                            year: '2010',
                                            details: '2010(15) 239-246, æŸ»èª­æœ‰ã‚Š'
                                        }
                                    ]
                                }
                            ]
                        },
                        {
                            name: 'GISãƒ»ç©ºé–“åˆ†æ',
                            description: 'åœ°ç†æƒ…å ±ã‚·ã‚¹ãƒ†ãƒ ãƒ»æ©Ÿæ¢°å­¦ç¿’å¿œç”¨',
                            level: 2,
                            children: [
                                { 
                                    name: 'ãƒ¯ã‚¤ãƒ³æ ½åŸ¹é©åœ°', 
                                    description: 'æ©Ÿæ¢°å­¦ç¿’ã‚’ç”¨ã„ãŸãƒ¯ã‚¤ãƒ³ç”¨ãƒ–ãƒ‰ã‚¦æ ½åŸ¹é©åœ°æ¨å®š', 
                                    level: 3,
                                    papers: [
                                        {
                                            title: 'æ©Ÿæ¢°å­¦ç¿’ã‚’ç”¨ã„ãŸãƒ¯ã‚¤ãƒ³ç”¨ãƒ–ãƒ‰ã‚¦æ ½åŸ¹é©åœ°ã®æ¨å®š',
                                            journal: 'GIS-ç†è«–ã¨å¿œç”¨',
                                            year: '2023',
                                            details: '31(2) 78-78, æ‹›å¾…æœ‰ã‚Š'
                                        },
                                        {
                                            title: 'CLIENT-SIDE WEB MAPPING SYSTEM FOR VINEYARD SUITABILITY ASSESSMENT',
                                            journal: 'The International Archives of the Photogrammetry, Remote Sensing and Spatial Information Sciences',
                                            year: '2022',
                                            details: 'XLVIII-4/W1-2022 223-228, æŸ»èª­æœ‰ã‚Š'
                                        }
                                    ]
                                },
                                { 
                                    name: 'ç©ºé–“è¨€èªå­¦', 
                                    description: 'è¨€èªå¤‰åŒ–ã®åœ°ç†çš„ãƒ‘ã‚¿ãƒ¼ãƒ³', 
                                    level: 3,
                                    papers: [
                                        {
                                            title: 'è¨€èªã®æ¶ˆå¤±ã¨ç²å¾—ã«é–¢é€£ã™ã‚‹ç’°å¢ƒãƒ»ç¤¾ä¼šçš„è¦å› ',
                                            journal: 'åœ°ç†æƒ…å ±ã‚·ã‚¹ãƒ†ãƒ å­¦ä¼šè¬›æ¼”è«–æ–‡é›†(CD-ROM)',
                                            year: '2016',
                                            details: '25 40-40, ç­†é ­è‘—è€…è²¬ä»»è‘—è€…'
                                        },
                                        {
                                            title: 'æ–¹è¨€åˆ†å¸ƒã‹ã‚‰è¦‹ãŸæ–‡åŒ–äº‹è±¡ã®æµé€šã¨æ»ç•™â€•å²é˜œçœŒã«ãŠã‘ã‚‹æ–¹è¨€åˆ†å¸ƒã®äº‹ä¾‹â€•',
                                            journal: 'åœ°ç†æƒ…å ±ã‚·ã‚¹ãƒ†ãƒ å­¦ä¼šè¬›æ¼”è«–æ–‡é›†(CD-ROM)',
                                            year: '2010',
                                            details: '19, 473-480'
                                        }
                                    ]
                                },
                                {
                                    name: 'AIãƒ»æ•™è‚²æŠ€è¡“',
                                    description: 'ãƒ‡ãƒ¼ã‚¿ã‚µã‚¤ã‚¨ãƒ³ã‚¹æ•™è‚²ãƒ»AIå¿œç”¨',
                                    level: 3,
                                    papers: [
                                        {
                                            title: 'å¯¾è©±å‹AIãƒ¢ãƒ‡ãƒ«ä¸¦ã³ã«AIéŸ³å£°ã‚’æ´»ç”¨ã—ãŸæ•™è‚²ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ä½œæˆ â€•AIæŠ€è¡“ã®æ–°ãŸãªå±•é–‹â€•',
                                            journal: 'ç¤¾ä¼šã¨çµ±è¨ˆ',
                                            year: '2024',
                                            details: '(10) 27-44'
                                        },
                                        {
                                            title: 'Python ã‚’åˆ©ç”¨ã—ãŸåœ°ç†ç·åˆå®Ÿç¿’ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã®ä½œæˆ',
                                            journal: 'æ—¥æœ¬åœ°ç†å­¦ä¼šç™ºè¡¨è¦æ—¨é›†',
                                            year: '2023',
                                            details: '2023s. P007'
                                        }
                                    ]
                                }
                            ]
                        },
                        { 
                            name: 'æ–‡åŒ–å¤šæ§˜æ€§æ©Ÿæ§‹', 
                            description: 'æ–‡åŒ–çš„å¤šæ§˜æ€§ã®é€²åŒ–ãƒ¡ã‚«ãƒ‹ã‚ºãƒ ', 
                            level: 2,
                            papers: [
                                {
                                    title: 'é›‘èªŒã€Œè¡Œå‹•è¨ˆé‡å­¦ã€ã«ãŠã‘ã‚‹è¨€èªã«é–¢ã™ã‚‹æŠ•ç¨¿è«–æ–‡ã®å‚¾å‘',
                                    journal: 'æ—¥æœ¬è¡Œå‹•è¨ˆé‡å­¦ä¼šå¤§ä¼šç™ºè¡¨è«–æ–‡æŠ„éŒ²é›†',
                                    year: '2012',
                                    details: '40 415-418'
                                }
                            ]
                        },
                        { 
                            name: 'æ–‡åŒ–ä¼é”ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯', 
                            description: 'ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ä¸Šã®æ–‡åŒ–ä¼é”ãƒ¢ãƒ‡ãƒ«', 
                            level: 2,
                            papers: [
                                {
                                    title: 'ITMAã«ãŠã‘ã‚‹NCDã®å®Ÿç”¨æ€§ã¨UMLã‚’ç”¨ã„ãŸåˆ†æãƒ—ãƒ­ã‚»ã‚¹ã®å¯è¦–åŒ–ã¨å…±æœ‰ã«ã¤ã„ã¦',
                                    journal: 'æƒ…å ±å‡¦ç†å­¦ä¼šã‚·ãƒ³ãƒã‚¸ã‚¦ãƒ è«–æ–‡é›†',
                                    year: '2010',
                                    details: '2010(15) 239-246, æŸ»èª­æœ‰ã‚Š'
                                },
                                {
                                    title: 'å²é˜œçœŒæ—§å¾³å±±æ‘ã«ãŠã‘ã‚‹ã‚¢ã‚¯ã‚»ãƒ³ãƒˆæ§˜ç›¸ã¨äº¤é€šçŠ¶æ³ã¨ã®é–¢ä¿‚æ€§-ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯åˆ†æã‚’ç”¨ã„ãŸã‚¢ã‚¯ã‚»ãƒ³ãƒˆåˆ†å¸ƒã¨äº¤é€šçŠ¶æ³ã®é¡ä¼¼æ€§ã®ç®—å‡º-',
                                    journal: 'æƒ…å ±å‡¦ç†å­¦ä¼šã‚·ãƒ³ãƒã‚¸ã‚¦ãƒ è«–æ–‡é›†',
                                    year: '2011',
                                    details: '2011(8) 219-224, æŸ»èª­æœ‰ã‚Šç­†é ­è‘—è€…'
                                }
                            ]
                        },
                        { 
                            name: 'å®šé‡çš„æ–¹è¨€å­¦', 
                            description: 'å²é˜œçœŒæ–¹è¨€èªå½™ã«ã‚ˆã‚‹æ–‡åŒ–é ˜åŸŸæŠ½å‡º', 
                            level: 2,
                            papers: [
                                {
                                    title: 'å²é˜œçœŒæ–¹è¨€èªå½™ã«ã‚ˆã‚‹ä»®æƒ³çš„æ–‡åŒ–é ˜åŸŸæŠ½å‡ºã¨èªå½™å¤‰åŒ–ã®æ–¹å‘',
                                    journal: 'ç ”ç©¶å ±å‘Šäººæ–‡ç§‘å­¦ã¨ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ï¼ˆCHï¼‰',
                                    year: '2012',
                                    details: '2012(4) 1-6, ç­†é ­è‘—è€…'
                                },
                                {
                                    title: 'æ–æ–å·ä¸ŠæµåŸŸã«ãŠã‘ã‚‹èªå½™ã®é¡å‹ã¨åœ°ç†çš„åˆ†å¸ƒ',
                                    journal: 'æ–‡åŒ–æƒ…å ±å­¦',
                                    year: '2012',
                                    details: '8(1) 1-11, æŸ»èª­æœ‰ã‚Šç­†é ­è‘—è€…'
                                },
                                {
                                    title: 'æ–æ–å·ä¸ŠæµåŸŸã®èªå½™ã«é–¢ã™ã‚‹ç³»çµ±æ¨å®š',
                                    journal: 'ç ”ç©¶å ±å‘Šäººæ–‡ç§‘å­¦ã¨ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ï¼ˆCHï¼‰',
                                    year: '2012',
                                    details: '2012(4) 1-6'
                                }
                            ]
                        }
                    ]
                }
            ]
        };

        class TreeChart {
            constructor(svgId, data) {
                this.svgElement = document.getElementById(svgId);
                this.data = data;
                this.tooltip = document.getElementById('tooltip');
                this.paperTooltip = document.getElementById('paper-tooltip');
                this.width = 1600;
                this.height = 1000;
                this.nodeRadius = { 0: 40, 1: 30, 2: 25, 3: 20, 4: 15, 5: 20 };
                this.fontSize = { 0: '18px', 1: '16px', 2: '14px', 3: '12px', 4: '10px', 5: '9px' };
                this.init();
            }

            init() {
                // D3.jsã§SVGã‚’è¨­å®š
                this.svg = d3.select(this.svgElement)
                    .attr('viewBox', `0 0 ${this.width} ${this.height}`);
                
                // ã‚ºãƒ¼ãƒ æ©Ÿèƒ½ã‚’è¿½åŠ 
                this.g = this.svg.append('g');
                
                // ã‚ºãƒ¼ãƒ å‹•ä½œã‚’å®šç¾©
                this.zoom = d3.zoom()
                    .scaleExtent([0.5, 2])
                    .on('zoom', (event) => {
                        this.g.attr('transform', event.transform);
                    });
                
                // SVGã«ã‚ºãƒ¼ãƒ å‹•ä½œã‚’é©ç”¨
                this.svg.call(this.zoom);
                
                // åˆæœŸã‚ºãƒ¼ãƒ ã‚’å°‘ã—ç¸®å°
                this.svg.call(this.zoom.transform, d3.zoomIdentity.scale(0.85));
                
                // ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³å®šç¾©
                const defs = this.g.append('defs');
                
                // èƒŒæ™¯ã®ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
                const treeGradient = defs.append('radialGradient')
                    .attr('id', 'treeGradient')
                    .attr('cx', '50%')
                    .attr('cy', '100%')
                    .attr('r', '100%');
                
                treeGradient.append('stop')
                    .attr('offset', '0%')
                    .attr('stop-color', '#D4AF37')
                    .attr('stop-opacity', 0.1);
                
                treeGradient.append('stop')
                    .attr('offset', '50%')
                    .attr('stop-color', '#FFD700')
                    .attr('stop-opacity', 0.05);
                
                treeGradient.append('stop')
                    .attr('offset', '100%')
                    .attr('stop-color', '#B8860B')
                    .attr('stop-opacity', 0.02);
                
                // åœ°é¢ã®ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
                const groundGradient = defs.append('linearGradient')
                    .attr('id', 'groundGradient')
                    .attr('x1', '0%').attr('y1', '0%')
                    .attr('x2', '0%').attr('y2', '100%');

                groundGradient.append('stop')
                    .attr('offset', '0%')
                    .attr('stop-color', '#654321')
                    .attr('stop-opacity', 0);
                groundGradient.append('stop')
                    .attr('offset', '70%')
                    .attr('stop-color', '#8B4513')
                    .attr('stop-opacity', 0.2);
                groundGradient.append('stop')
                    .attr('offset', '90%')
                    .attr('stop-color', '#654321')
                    .attr('stop-opacity', 0.4);

                // æ ¹ãƒãƒ¼ãƒ‰ç”¨ã®ç‰¹åˆ¥ãªã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
                const rootGradient = defs.append('radialGradient')
                    .attr('id', 'rootGradient');
                rootGradient.append('stop')
                    .attr('offset', '0%')
                    .attr('stop-color', '#FFD700')
                    .attr('stop-opacity', 1);
                rootGradient.append('stop')
                    .attr('offset', '60%')
                    .attr('stop-color', '#DAA520')
                    .attr('stop-opacity', 0.9);
                rootGradient.append('stop')
                    .attr('offset', '100%')
                    .attr('stop-color', '#8B4513')
                    .attr('stop-opacity', 0.8);

                // æã®ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆå„æã”ã¨ã«ä½œæˆï¼‰
                for (let i = 0; i < 50; i++) {
                    const branchGrad = defs.append('linearGradient')
                        .attr('id', `branchGradient${i}`)
                        .attr('x1', '0%').attr('y1', '0%')
                        .attr('x2', '100%').attr('y2', '100%');
                    
                    branchGrad.append('stop')
                        .attr('offset', '0%')
                        .attr('stop-color', '#8B4513')
                        .attr('stop-opacity', 0.9);
                    
                    branchGrad.append('stop')
                        .attr('offset', '100%')
                        .attr('stop-color', '#DAA520')
                        .attr('stop-opacity', 0.7);
                }

                // é‡‘å±çš„ãªè³ªæ„Ÿã‚’è¡¨ç¾ã™ã‚‹ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼
                const goldFilter = defs.append('filter')
                    .attr('id', 'goldLeaf')
                    .attr('x', '-50%')
                    .attr('y', '-50%')
                    .attr('width', '200%')
                    .attr('height', '200%');
                
                // å…‰æ²¢åŠ¹æœ
                goldFilter.append('feGaussianBlur')
                    .attr('in', 'SourceAlpha')
                    .attr('stdDeviation', '2')
                    .attr('result', 'blur');
                
                goldFilter.append('feSpecularLighting')
                    .attr('in', 'blur')
                    .attr('surfaceScale', '5')
                    .attr('specularConstant', '2')
                    .attr('specularExponent', '20')
                    .attr('lighting-color', '#ffd700')
                    .attr('result', 'specOut');
                
                goldFilter.append('feComposite')
                    .attr('in', 'specOut')
                    .attr('in2', 'SourceAlpha')
                    .attr('operator', 'in')
                    .attr('result', 'specOut2');
                
                goldFilter.append('feComposite')
                    .attr('in', 'SourceGraphic')
                    .attr('in2', 'specOut2')
                    .attr('operator', 'arithmetic')
                    .attr('k1', '0')
                    .attr('k2', '1')
                    .attr('k3', '1')
                    .attr('k4', '0');
                
                // ãƒ–ãƒ­ãƒ³ã‚ºåŠ¹æœãƒ•ã‚£ãƒ«ã‚¿ãƒ¼
                const bronzeFilter = defs.append('filter')
                    .attr('id', 'bronze')
                    .attr('x', '-50%')
                    .attr('y', '-50%')
                    .attr('width', '200%')
                    .attr('height', '200%');
                
                bronzeFilter.append('feGaussianBlur')
                    .attr('in', 'SourceAlpha')
                    .attr('stdDeviation', '1.5')
                    .attr('result', 'blur');
                
                bronzeFilter.append('feSpecularLighting')
                    .attr('in', 'blur')
                    .attr('surfaceScale', '3')
                    .attr('specularConstant', '1.5')
                    .attr('specularExponent', '15')
                    .attr('lighting-color', '#cd7f32')
                    .attr('result', 'specOut');
                
                bronzeFilter.append('feComposite')
                    .attr('in', 'specOut')
                    .attr('in2', 'SourceAlpha')
                    .attr('operator', 'in')
                    .attr('result', 'specOut2');
                
                bronzeFilter.append('feComposite')
                    .attr('in', 'SourceGraphic')
                    .attr('in2', 'specOut2')
                    .attr('operator', 'arithmetic')
                    .attr('k1', '0')
                    .attr('k2', '1')
                    .attr('k3', '1')
                    .attr('k4', '0');

                // è£…é£¾ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’å®šç¾©ï¼ˆã‚¯ãƒªãƒ ãƒˆé¢¨ã®æ¸¦å·»ãæ¨¡æ§˜ï¼‰
                const pattern = defs.append('pattern')
                    .attr('id', 'klimtPattern')
                    .attr('patternUnits', 'userSpaceOnUse')
                    .attr('width', 60)
                    .attr('height', 60);
                
                // æ¸¦å·»ãæ¨¡æ§˜ï¼ˆé‡‘è‰²ã‚’æ§ãˆã‚ã«ï¼‰
                const spiralGroup = pattern.append('g');
                
                // ä¸­å¿ƒã®å††
                spiralGroup.append('circle')
                    .attr('cx', 30)
                    .attr('cy', 30)
                    .attr('r', 4)
                    .attr('fill', 'none')
                    .attr('stroke', '#d4af37')
                    .attr('stroke-width', 1)
                    .attr('opacity', 0.3);
                
                // æ¸¦å·»ããƒ‘ã‚¹
                const spiral = d3.path();
                const turns = 2;
                const pointsPerTurn = 30;
                for (let i = 0; i <= turns * pointsPerTurn; i++) {
                    const angle = (i / pointsPerTurn) * 2 * Math.PI;
                    const radius = 5 + (i / pointsPerTurn) * 10;
                    const x = 30 + Math.cos(angle) * radius;
                    const y = 30 + Math.sin(angle) * radius;
                    if (i === 0) {
                        spiral.moveTo(x, y);
                    } else {
                        spiral.lineTo(x, y);
                    }
                }
                
                spiralGroup.append('path')
                    .attr('d', spiral.toString())
                    .attr('fill', 'none')
                    .attr('stroke', '#b8860b')
                    .attr('stroke-width', 0.8)
                    .attr('opacity', 0.2);
                
                // å°ã•ãªå††ã®è£…é£¾
                [15, 45].forEach(x => {
                    [15, 45].forEach(y => {
                        spiralGroup.append('circle')
                            .attr('cx', x)
                            .attr('cy', y)
                            .attr('r', 2)
                            .attr('fill', '#d4af37')
                            .attr('opacity', 0.2);
                    });
                });

                // è‘‰ã£ã±ã®å½¢çŠ¶ã‚’å®šç¾©
                defs.append('path')
                    .attr('id', 'leafShape')
                    .attr('d', 'M0,-15 Q-10,-5 -10,5 Q-10,15 0,20 Q10,15 10,5 Q10,-5 0,-15');

                // èƒŒæ™¯ãƒ¬ã‚¤ãƒ¤ãƒ¼
                this.g.append('rect')
                    .attr('width', this.width)
                    .attr('height', this.height)
                    .attr('fill', '#fafafa')
                    .on('click', () => {
                        this.g.selectAll('.node-text').classed('fixed', false).classed('visible', false);
                    });
                
                // ã‚¯ãƒªãƒ ãƒˆãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’æ§ãˆã‚ã«é©ç”¨
                this.g.append('rect')
                    .attr('width', this.width)
                    .attr('height', this.height)
                    .attr('fill', 'url(#klimtPattern)')
                    .attr('opacity', 0.08)
                    .style('pointer-events', 'none');
                
                this.processData();
                this.createForceSimulation();
                this.setupControls();
            }

            processData() {
                const nodes = [];
                const links = [];
                let nodeId = 0;
                const height = this.height;
                const width = this.width;
                
                // ãƒ«ãƒ¼ãƒˆãƒãƒ¼ãƒ‰
                const root = {
                    id: nodeId++,
                    name: this.data.name,
                    description: this.data.description,
                    level: 0,
                    x: width / 2,
                    y: height - 100,
                    fx: width / 2,
                    fy: height - 100
                };
                nodes.push(root);

                // å†å¸°çš„ã«ãƒãƒ¼ãƒ‰ã¨ãƒªãƒ³ã‚¯ã‚’ä½œæˆ
                const processChildren = (parent, children, level) => {
                    if (!children) return;
                    
                    children.forEach((child, i) => {
                        const node = {
                            id: nodeId++,
                            name: child.name,
                            description: child.description,
                            level: level,
                            papers: child.papers || []
                        };
                        
                        // ãƒ¬ãƒ™ãƒ«ã«å¿œã˜ã¦åˆæœŸåº§æ¨™ã‚’è¨­å®š
                        if (level === 1) {
                            node.x = width / 2 + (Math.random() - 0.5) * 200;
                            node.y = height - 250;
                        } else if (level === 2) {
                            node.x = width / 2 + (Math.random() - 0.5) * 400;
                            node.y = height - 500;
                        } else {
                            node.x = width / 2 + (Math.random() - 0.5) * 600;
                            node.y = height - 750;
                        }
                        
                        nodes.push(node);
                        
                        // ãƒªãƒ³ã‚¯ã‚’ä½œæˆ
                        if (parent.level === 1 && child.papers && child.papers.length > 0) {
                            links.push({ source: parent.id, target: node.id, papers: child.papers });
                        } else {
                            links.push({ source: parent.id, target: node.id });
                        }
                        
                        // å­ãƒãƒ¼ãƒ‰ã‚’å‡¦ç†
                        if (child.children) {
                            processChildren(node, child.children, level + 1);
                        }
                        
                        // è«–æ–‡ãƒãƒ¼ãƒ‰ã‚’è¿½åŠ 
                        if (child.papers && child.papers.length > 0) {
                            const maxPapers = 5;
                            const papersToShow = Math.min(child.papers.length, maxPapers);
                            
                            child.papers.slice(0, papersToShow).forEach((paper, k) => {
                                const paperNode = {
                                    id: nodeId++,
                                    name: paper.year,
                                    description: paper.title,
                                    level: level + 1,
                                    paper: paper,
                                    x: node.x || width / 2,
                                    y: height - (200 + level * 150)
                                };
                                nodes.push(paperNode);
                                links.push({ source: node.id, target: paperNode.id });
                            });
                            
                            // è¿½åŠ ã®è«–æ–‡ãƒãƒ¼ãƒ‰
                            if (child.papers.length > maxPapers) {
                                const moreNode = {
                                    id: nodeId++,
                                    name: `+${child.papers.length - maxPapers}`,
                                    description: `ä»–${child.papers.length - maxPapers}ä»¶ã®è«–æ–‡`,
                                    level: level + 1,
                                    morePapers: child.papers.slice(maxPapers),
                                    x: node.x || width / 2,
                                    y: height - (200 + level * 150)
                                };
                                nodes.push(moreNode);
                                links.push({ source: node.id, target: moreNode.id });
                            }
                        }
                    });
                };

                processChildren(root, this.data.children, 1);
                
                this.nodes = nodes;
                this.links = links;
            }

            createForceSimulation() {
                // å¹´ä»£ã«ã‚ˆã‚‹è‰²ã‚’è¿”ã™é–¢æ•°
                const getYearColor = (papers) => {
                    if (!papers || papers.length === 0) return '#666666';
                    
                    const latestYear = Math.max(...papers.map(p => parseInt(p.year) || 2010));
                    
                    if (latestYear >= 2023) return '#1e40af';
                    else if (latestYear >= 2019) return '#2563eb';
                    else if (latestYear >= 2016) return '#3b82f6';
                    else if (latestYear >= 2013) return '#60a5fa';
                    else return '#93c5fd';
                };
                
                // ãƒãƒ¼ãƒ‰ã®æœ€æ–°è«–æ–‡å¹´ã‚’å–å¾—ã™ã‚‹é–¢æ•°
                const getLatestYear = (node) => {
                    if (node.paper) return parseInt(node.paper.year) || 2010;
                    if (node.papers && node.papers.length > 0) {
                        return Math.max(...node.papers.map(p => parseInt(p.year) || 2010));
                    }
                    let latestYear = 2010;
                    this.nodes.forEach(n => {
                        if (n.level === node.level + 1) {
                            const isChild = this.links.some(l => 
                                (l.source === node.id || l.source.id === node.id) && 
                                (l.target === n.id || l.target.id === n.id)
                            );
                            if (isChild) {
                                const childYear = getLatestYear(n);
                                latestYear = Math.max(latestYear, childYear);
                            }
                        }
                    });
                    return latestYear;
                };
                
                // è‘‰ã£ã±ã®è‰²ã‚’è¨ˆç®—ã™ã‚‹é–¢æ•°ï¼ˆé‡‘è‰²ç³»ï¼‰
                const getLeafColor = (year) => {
                    const yearNum = parseInt(year) || 2010;
                    const t = (yearNum - 2010) / 14; // 0-1ã«æ­£è¦åŒ–
                    // å¤ã„è«–æ–‡ã¯èŒ¶è‰²ã€æ–°ã—ã„è«–æ–‡ã¯æ˜ã‚‹ã„é‡‘è‰²
                    return d3.interpolateRgb('#8b6914', '#d4af37')(t);
                };
                
                // ãƒãƒ¼ãƒ‰IDã¨ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã®ãƒãƒƒãƒ—ã‚’ä½œæˆ
                this.nodeMap = {};
                this.nodes.forEach((node, i) => {
                    this.nodeMap[node.id] = i;
                });
                
                // åŠ›å­¦ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ä½œæˆ
                this.simulation = d3.forceSimulation(this.nodes)
                    .force('link', d3.forceLink(this.links)
                        .id(d => d.id)
                        .distance(d => {
                            const sourceNode = typeof d.source === 'object' ? d.source : this.nodes.find(n => n.id === d.source);
                            const targetNode = typeof d.target === 'object' ? d.target : this.nodes.find(n => n.id === d.target);
                            if (!sourceNode || !targetNode) return 100;
                            
                            let baseDistance;
                            if (sourceNode.level === 0) baseDistance = 200;
                            else if (sourceNode.level === 1) baseDistance = 160;
                            else if (sourceNode.level === 2) baseDistance = 120;
                            else baseDistance = 80;
                            
                            return baseDistance * (0.5 + Math.random());
                        })
                        .strength(0.8))
                    .force('charge', d3.forceManyBody()
                        .strength(d => {
                            if (d.level === 0) return -3000;
                            if (d.level === 1) return -2500;
                            if (d.level === 2) return -2000;
                            if (d.level === 3) return -1500;
                            if (d.level === 4) return -1200;
                            return -1500;
                        }))
                    .force('x', d3.forceX(d => {
                        if (d.level === 0) return this.width / 2;
                        
                        if (d.paper) {
                            const year = parseInt(d.paper.year) || 2010;
                            const yearOffset = (year - 2010) / 14;
                            const spread = (Math.random() - 0.5) * 200 * (1 + yearOffset);
                            return this.width / 2 + spread;
                        }
                        
                        const latestYear = getLatestYear(d);
                        const yearOffset = (latestYear - 2010) / 14;
                        const spread = (Math.random() - 0.5) * 100 * yearOffset;
                        
                        return this.width / 2 + spread;
                    }).strength(0.1))
                    .force('y', d3.forceY(d => {
                        if (d.level === 0) return this.height - 100;
                        
                        if (d.paper) {
                            const year = parseInt(d.paper.year) || 2010;
                            const yearOffset = (year - 2010) / 14;
                            return this.height - 850 + (1 - yearOffset) * 100;
                        }
                        
                        const latestYear = getLatestYear(d);
                        const yearOffset = (latestYear - 2010) / 14;
                        
                        let baseY;
                        if (d.level === 1) baseY = this.height - 300;
                        else if (d.level === 2) baseY = this.height - 500;
                        else if (d.level === 3) baseY = this.height - 650;
                        else if (d.level === 4) baseY = this.height - 750;
                        else baseY = this.height - 850;
                        
                        return baseY - yearOffset * 150;
                    }).strength(0.7))
                    .force('collision', d3.forceCollide()
                        .radius(d => {
                            if (d.paper) return this.nodeRadius[d.level] + 60;
                            if (d.level >= 3) return this.nodeRadius[d.level] + 40;
                            return this.nodeRadius[d.level] + 30;
                        })
                        .strength(0.8));

                // ãƒªãƒ³ã‚¯ã‚’æç”»
                const linkGroup = this.g.append('g').attr('class', 'links');
                const link = linkGroup.selectAll('path')
                    .data(this.links)
                    .enter().append('path')
                    .attr('class', 'link')
                    .attr('stroke', '#8B6914')  // ã‚ˆã‚Šæ¿ƒã„èŒ¶è‰²
                    .attr('stroke-width', d => {
                        const sourceNode = typeof d.source === 'object' ? d.source : this.nodes.find(n => n.id === d.source);
                        if (!sourceNode) return 2;
                        if (sourceNode.level === 0) return 12;  // æ ¹ã‹ã‚‰ã®å¹¹ã¯å¤ªã
                        if (sourceNode.level === 1) return 6;   // ä¸»è¦ãªæ
                        if (sourceNode.level === 2) return 4;   // å°æ
                        return 2;  // ç´°ã„æ
                    })
                    .attr('fill', 'none')
                    .attr('opacity', d => {
                        const sourceNode = typeof d.source === 'object' ? d.source : this.nodes.find(n => n.id === d.source);
                        if (!sourceNode) return 0.6;
                        if (sourceNode.level === 0) return 0.9;  // å¹¹ã¯æ¿ƒã
                        return 0.7;
                    })
                    .attr('stroke-linecap', 'round')
                    .attr('stroke-linejoin', 'round');

                // ãƒãƒ¼ãƒ‰ã‚°ãƒ«ãƒ¼ãƒ—ã‚’ä½œæˆ
                const nodeGroup = this.g.append('g').attr('class', 'nodes');
                const node = nodeGroup.selectAll('g')
                    .data(this.nodes)
                    .enter().append('g')
                    .attr('class', 'node')
                    .style('cursor', 'pointer')
                    .call(d3.drag()
                        .on('start', (event, d) => this.dragstarted(event, d))
                        .on('drag', (event, d) => this.dragged(event, d))
                        .on('end', (event, d) => this.dragended(event, d)));

                // ãƒãƒ¼ãƒ‰ã®å††ã‚’è¿½åŠ 
                node.append('circle')
                    .attr('r', d => {
                        if (d.paper) return 16;
                        return this.nodeRadius[d.level] || 15;
                    })
                    .attr('class', d => `node-circle level-${d.level}`)
                    .attr('fill', d => {
                        if (d.paper && d.paper.year) {
                            return getYearColor([d.paper]);
                        }
                        if (d.morePapers && d.morePapers.length > 0) {
                            return getYearColor(d.morePapers);
                        }
                        if (d.papers && d.papers.length > 0) {
                            return getYearColor(d.papers);
                        }
                        // ãƒ¬ãƒ™ãƒ«ã”ã¨ã®è‰²ï¼ˆæ ¹ã¯é‡‘è‰²ç³»ã€ä»–ã¯ã‚°ãƒ¬ãƒ¼ã‚¹ã‚±ãƒ¼ãƒ«ï¼‰
                        if (d.level === 0) return '#b8860b';  // ãƒ€ãƒ¼ã‚¯ã‚´ãƒ¼ãƒ«ãƒ‡ãƒ³ãƒ­ãƒƒãƒ‰
                        if (d.level === 1) return '#4b5563';
                        if (d.level === 2) return '#6b7280';
                        if (d.level === 3) return '#9ca3af';
                        return '#d1d5db';
                    })
                    .attr('stroke', d => {
                        if (d.paper) return '#e5e7eb';
                        if (d.level === 0) return '#d4af37';  // æ ¹ã¯é‡‘è‰²ã®ç¸
                        return '#d1d5db';
                    })
                    .attr('stroke-width', d => {
                        if (d.level === 0) return 3;
                        return d.paper ? 1 : 2;
                    })
                    .style('filter', d => {
                        if (d.level === 0) return 'url(#goldLeaf)';  // æ ¹ãƒãƒ¼ãƒ‰ã«é‡‘ç®”åŠ¹æœ
                        if (d.level === 1) return 'url(#bronze)';     // ç¬¬1éšå±¤ã«ãƒ–ãƒ­ãƒ³ã‚ºåŠ¹æœ
                        return null;
                    });

                // é–‹èŠ±è£…é£¾ã‚’è¿½åŠ ï¼ˆãƒ¬ãƒ™ãƒ«0-2ã®ãƒãƒ¼ãƒ‰ã«ï¼‰
                const flowerNodes = node.filter(d => d.level <= 2);
                
                flowerNodes.each(function(d) {
                    const flowerGroup = d3.select(this).append('g')
                        .attr('class', 'flower-decoration');
                    
                    // èŠ±ã³ã‚‰ã®æ•°ï¼ˆãƒ¬ãƒ™ãƒ«ã«ã‚ˆã£ã¦å¤‰åŒ–ï¼‰
                    const petalCount = d.level === 0 ? 8 : (d.level === 1 ? 6 : 4);
                    const petalRadius = d.level === 0 ? 25 : (d.level === 1 ? 20 : 15);
                    
                    // èŠ±ã³ã‚‰ã‚’ç”Ÿæˆ
                    for (let i = 0; i < petalCount; i++) {
                        const angle = (i / petalCount) * 2 * Math.PI;
                        const petalPath = d3.path();
                        
                        // èŠ±ã³ã‚‰ã®å½¢ã‚’æç”»ï¼ˆãƒãƒ¼ãƒˆå‹ã®èŠ±ã³ã‚‰ï¼‰
                        petalPath.moveTo(0, 0);
                        petalPath.quadraticCurveTo(
                            -petalRadius * 0.5 * Math.cos(angle) - petalRadius * 0.2 * Math.sin(angle),
                            -petalRadius * 0.5 * Math.sin(angle) + petalRadius * 0.2 * Math.cos(angle),
                            -petalRadius * Math.cos(angle),
                            -petalRadius * Math.sin(angle)
                        );
                        petalPath.quadraticCurveTo(
                            -petalRadius * 0.5 * Math.cos(angle) + petalRadius * 0.2 * Math.sin(angle),
                            -petalRadius * 0.5 * Math.sin(angle) - petalRadius * 0.2 * Math.cos(angle),
                            0, 0
                        );
                        
                        flowerGroup.append('path')
                            .attr('d', petalPath.toString())
                            .attr('class', 'petal')
                            .attr('transform', `rotate(${(angle * 180 / Math.PI)})`)
                            .style('filter', d.level === 0 ? 'url(#goldLeaf)' : null)
                            .style('animation-delay', `${i * 0.1}s`);
                    }
                    
                    // ä¸­å¿ƒã«å°ã•ãªå††ï¼ˆèŠ±ã®ä¸­å¿ƒï¼‰
                    if (d.level === 0) {
                        flowerGroup.append('circle')
                            .attr('r', 5)
                            .attr('fill', '#ffd700')
                            .attr('opacity', 0.8)
                            .style('filter', 'url(#goldLeaf)');
                    }
                });
                
                // è£…é£¾çš„ãªè‘‰ã£ã±ã‚’ãƒªãƒ³ã‚¯ã®ä¸­é–“ç‚¹ä»˜è¿‘ã«é…ç½®
                const leafGroup = this.g.append('g').attr('class', 'leaves');
                
                // å„ãƒªãƒ³ã‚¯ã«å¯¾ã—ã¦è‘‰ã£ã±ã‚’é…ç½®ï¼ˆãƒ©ãƒ³ãƒ€ãƒ ã«é¸æŠï¼‰
                this.links.forEach((link, i) => {
                    // 30%ã®ç¢ºç‡ã§è‘‰ã£ã±ã‚’é…ç½®
                    if (Math.random() < 0.3) {
                        const leafCount = Math.floor(Math.random() * 3) + 1; // 1-3æšã®è‘‰
                        
                        for (let j = 0; j < leafCount; j++) {
                            // ãƒªãƒ³ã‚¯ã«æ²¿ã£ãŸä½ç½®ï¼ˆ20%-80%ã®ç¯„å›²ã§ãƒ©ãƒ³ãƒ€ãƒ ï¼‰
                            const t = 0.2 + Math.random() * 0.6;
                            
                            // ã‚ªãƒ•ã‚»ãƒƒãƒˆï¼ˆãƒªãƒ³ã‚¯ã‹ã‚‰å°‘ã—é›¢ã‚ŒãŸä½ç½®ï¼‰
                            const offsetAngle = Math.random() * Math.PI * 2;
                            const offsetDistance = 20 + Math.random() * 40;
                            
                            const leaf = leafGroup.append('g')
                                .attr('class', 'decorative-leaf')
                                .attr('opacity', 0.7 + Math.random() * 0.3);
                            
                            // è‘‰ã£ã±ã®è‰²ï¼ˆãƒ©ãƒ³ãƒ€ãƒ ãªå¹´ä»£é¢¨ï¼‰
                            const randomYear = 2010 + Math.floor(Math.random() * 15);
                            const leafColor = getLeafColor(randomYear);
                            
                            leaf.append('path')
                                .attr('d', 'M0,-15 Q-8,-6 -8,6 Q-8,15 0,18 Q8,15 8,6 Q8,-6 0,-15')
                                .attr('fill', leafColor)
                                .attr('stroke', '#2F4F2F')
                                .attr('stroke-width', 0.8)
                                .attr('transform', `rotate(${Math.random() * 360})`)
                                .style('filter', 'drop-shadow(0 2px 3px rgba(0, 0, 0, 0.2))');
                            
                            // è‘‰ã£ã±ã®ä½ç½®ã‚’ä¿å­˜ï¼ˆã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³æ™‚ã«æ›´æ–°ï¼‰
                            leaf.node().__data__ = {
                                linkIndex: i,
                                t: t,
                                offsetAngle: offsetAngle,
                                offsetDistance: offsetDistance
                            };
                        }
                    }
                });

                // è‘‰ã£ã±ã®è‰²ã‚’æ§ãˆã‚ã«
                
                // è«–æ–‡ãƒãƒ¼ãƒ‰ã«çµæ™¶è£…é£¾ã‚’è¿½åŠ 
                const paperNodes = node.filter(d => d.paper);
                
                paperNodes.each(function(d) {
                    const crystalGroup = d3.select(this).append('g')
                        .attr('class', 'flower-decoration');
                    
                    // çµæ™¶ã®å½¢ï¼ˆ8æ–¹å‘ã®é‡çŠ¶ï¼‰
                    const crystalSize = 12;
                    for (let i = 0; i < 8; i++) {
                        const angle = (i / 8) * 2 * Math.PI;
                        const length = i % 2 === 0 ? crystalSize : crystalSize * 0.7;
                        
                        crystalGroup.append('line')
                            .attr('x1', 0)
                            .attr('y1', 0)
                            .attr('x2', Math.cos(angle) * length)
                            .attr('y2', Math.sin(angle) * length)
                            .attr('stroke', getYearColor([d.paper]))
                            .attr('stroke-width', 2)
                            .attr('opacity', 0.6);
                    }
                    
                    // ä¸­å¿ƒã®å°ã•ãªå††
                    crystalGroup.append('circle')
                        .attr('r', 3)
                        .attr('fill', getYearColor([d.paper]))
                        .attr('opacity', 0.8);
                });

                // ãƒãƒ¼ãƒ‰ã®ãƒ†ã‚­ã‚¹ãƒˆã‚’è¿½åŠ ï¼ˆç¸å–ã‚Šä»˜ãï¼‰
                node.append('text')
                    .attr('class', 'node-text')
                    .attr('fill', 'black')
                    .attr('font-size', d => this.fontSize[d.level])
                    .attr('text-anchor', 'middle')
                    .attr('dominant-baseline', 'central')
                    .attr('stroke', '#ffffff')
                    .attr('stroke-width', '4px')
                    .attr('paint-order', 'stroke')
                    .attr('font-weight', d => {
                        if (d.level === 0) return '800';
                        if (d.level === 1) return '700';
                        if (d.level === 2) return '600';
                        if (d.level === 3) return '500';
                        return '400';
                    })
                    .text(d => d.name);
                
                // å‰é¢ã®ãƒ†ã‚­ã‚¹ãƒˆï¼ˆé»’è‰²ï¼‰
                node.append('text')
                    .attr('class', 'node-text')
                    .attr('fill', '#000000')
                    .attr('font-size', d => this.fontSize[d.level])
                    .attr('text-anchor', 'middle')
                    .attr('dominant-baseline', 'central')
                    .attr('font-weight', d => {
                        if (d.level === 0) return '800';
                        if (d.level === 1) return '700';
                        if (d.level === 2) return '600';
                        if (d.level === 3) return '500';
                        return '400';
                    })
                    .text(d => d.name);

                // ãƒ›ãƒãƒ¼ã‚¤ãƒ™ãƒ³ãƒˆã¨ã‚¯ãƒªãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆ
                node.on('mouseenter', (event, d) => {
                    this.showTooltip(event, d);
                    const nodeElement = d3.select(event.currentTarget);
                    nodeElement.selectAll('.node-text').each(function() {
                        if (!d3.select(this).classed('fixed')) {
                            d3.select(this).classed('visible', true);
                        }
                    });
                })
                .on('mouseleave', (event, d) => {
                    this.hideTooltip();
                    const nodeElement = d3.select(event.currentTarget);
                    nodeElement.selectAll('.node-text').each(function() {
                        if (!d3.select(this).classed('fixed')) {
                            d3.select(this).classed('visible', false);
                        }
                    });
                })
                .on('mousemove', (event) => this.updateTooltipPosition(event))
                .on('click', (event, d) => {
                    event.stopPropagation();
                    const nodeElement = d3.select(event.currentTarget);
                    nodeElement.selectAll('.node-text').each(function() {
                        const isFixed = d3.select(this).classed('fixed');
                        d3.select(this).classed('fixed', !isFixed);
                        if (!isFixed) {
                            d3.select(this).classed('visible', true);
                        }
                    });
                });

                // è«–æ–‡ãŒã‚ã‚‹æã«ã‚¤ãƒ³ã‚¸ã‚±ãƒ¼ã‚¿ãƒ¼ã‚’è¿½åŠ 
                const paperIndicators = linkGroup.selectAll('.paper-indicator')
                    .data(this.links.filter(d => d.papers && d.papers.length > 0))
                    .enter().append('g')
                    .attr('class', 'paper-indicator-group');

                paperIndicators.append('circle')
                    .attr('r', 6)
                    .attr('fill', '#2563eb')
                    .attr('class', 'paper-indicator')
                    .on('mouseenter', (event, d) => {
                        const targetNode = typeof d.target === 'object' ? d.target : this.nodes.find(n => n.id === d.target);
                        if (targetNode) {
                            this.showPaperTooltip(event, d.papers, targetNode.name);
                        }
                    })
                    .on('mouseleave', () => this.hidePaperTooltip())
                    .on('mousemove', (event) => this.updatePaperTooltipPosition(event));

                paperIndicators.append('text')
                    .attr('fill', '#000000')
                    .attr('font-size', '10px')
                    .attr('font-weight', 'bold')
                    .attr('text-anchor', 'middle')
                    .attr('dominant-baseline', 'central')
                    .attr('pointer-events', 'none')
                    .attr('stroke', '#ffffff')
                    .attr('stroke-width', '2px')
                    .attr('paint-order', 'stroke')
                    .text(d => d.papers.length);

                // ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã®ãƒ†ã‚£ãƒƒã‚¯å‡¦ç†
                this.simulation.on('tick', () => {
                    // ãƒªãƒ³ã‚¯ã‚’ã‚ˆã‚Šè‡ªç„¶ãªæ›²ç·šã§æç”»
                    link.attr('d', d => {
                        const source = d.source;
                        const target = d.target;
                        if (!source || !target) return '';
                        
                        // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆãŒè«–æ–‡ãƒãƒ¼ãƒ‰ã®å ´åˆã€è«–æ–‡ãƒãƒ¼ãƒ‰ã‚’ä¸­å¿ƒã¨ã—ãŸæ¸¦å·»ãã‚’æã
                        if (target.paper && source.level >= 2) {
                            const centerX = target.x;
                            const centerY = target.y;
                            
                            const dx = centerX - source.x;
                            const dy = centerY - source.y;
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            const angle = Math.atan2(dy, dx);
                            
                            const spirals = 2;
                            const maxRadius = Math.min(distance * 0.7, 80);
                            const minRadius = 25;
                            const points = [];
                            const steps = 60;
                            
                            points.push([source.x, source.y]);
                            
                            const connectionLength = distance * 0.3;
                            for (let i = 1; i <= 10; i++) {
                                const t = i / 10;
                                const x = source.x + dx * t * 0.3;
                                const y = source.y + dy * t * 0.3;
                                points.push([x, y]);
                            }
                            
                            for (let i = 0; i <= steps; i++) {
                                const t = i / steps;
                                const spiralAngle = angle + spirals * 2 * Math.PI * t;
                                const r = maxRadius * (1 - t * 0.8) + minRadius * (t * 0.8);
                                
                                const x = centerX - r * Math.cos(spiralAngle);
                                const y = centerY - r * Math.sin(spiralAngle);
                                
                                points.push([x, y]);
                            }
                            
                            const line = d3.line().curve(d3.curveBasis);
                            return line(points);
                        } else {
                            // é€šå¸¸ã®è‡ªç„¶ãªæ›²ç·š
                            const dx = target.x - source.x;
                            const dy = target.y - source.y;
                            const dr = Math.sqrt(dx * dx + dy * dy);
                            
                            // æã®ã€ŒãŸã‚ã¿ã€ã‚’è¿½åŠ 
                            const sweep = Math.random() * 0.3 + 0.2;
                            const controlPoint1X = source.x + dx * 0.25 + dy * sweep;
                            const controlPoint1Y = source.y + dy * 0.25 - dx * sweep;
                            const controlPoint2X = source.x + dx * 0.75 - dy * sweep * 0.5;
                            const controlPoint2Y = source.y + dy * 0.75 + dx * sweep * 0.5;
                            
                            return `M${source.x},${source.y} C${controlPoint1X},${controlPoint1Y} ${controlPoint2X},${controlPoint2Y} ${target.x},${target.y}`;
                        }
                    });

                    // ãƒãƒ¼ãƒ‰ã®ä½ç½®ã‚’æ›´æ–°
                    node.attr('transform', d => `translate(${d.x}, ${d.y})`);

                    // è«–æ–‡ã‚¤ãƒ³ã‚¸ã‚±ãƒ¼ã‚¿ãƒ¼ã®ä½ç½®ã‚’æ›´æ–°
                    paperIndicators.attr('transform', d => {
                        if (!d.source || !d.target) return '';
                        const midX = (d.source.x + d.target.x) / 2;
                        const midY = (d.source.y + d.target.y) / 2;
                        return `translate(${midX}, ${midY})`;
                    });
                    
                    // è£…é£¾çš„ãªè‘‰ã£ã±ã®ä½ç½®ã‚’æ›´æ–°
                    const linksData = this.links;
                    leafGroup.selectAll('.decorative-leaf').attr('transform', function(d) {
                        const leafData = this.__data__;
                        if (!leafData) return '';
                        
                        const link = linksData[leafData.linkIndex];
                        if (!link.source || !link.target) return '';
                        
                        // ãƒªãƒ³ã‚¯ã®ä¸­é–“ç‚¹ã‚’è¨ˆç®—
                        const sourceX = link.source.x;
                        const sourceY = link.source.y;
                        const targetX = link.target.x;
                        const targetY = link.target.y;
                        
                        // t ã®ä½ç½®ã‚’è¨ˆç®—
                        const x = sourceX + (targetX - sourceX) * leafData.t;
                        const y = sourceY + (targetY - sourceY) * leafData.t;
                        
                        // ã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’é©ç”¨
                        const offsetX = x + Math.cos(leafData.offsetAngle) * leafData.offsetDistance;
                        const offsetY = y + Math.sin(leafData.offsetAngle) * leafData.offsetDistance;
                        
                        return `translate(${offsetX}, ${offsetY})`;
                    });
                });

                this.link = link;
                this.node = node;
                this.paperIndicators = paperIndicators;
                this.leafGroup = leafGroup;
            }

            dragstarted(event, d) {
                if (!event.active) this.simulation.alphaTarget(0.3).restart();
                d.fx = d.x;
                d.fy = d.y;
            }

            dragged(event, d) {
                d.fx = event.x;
                d.fy = event.y;
            }

            dragended(event, d) {
                if (!event.active) this.simulation.alphaTarget(0);
                if (d.level !== 0) {
                    d.fx = null;
                    d.fy = null;
                }
            }

            setupControls() {
                document.getElementById('restart-simulation').addEventListener('click', () => {
                    this.nodes.forEach(d => {
                        if (d.level !== 0) {
                            d.fx = null;
                            d.fy = null;
                        }
                    });
                    this.simulation.alpha(1).restart();
                });

                document.getElementById('freeze-simulation').addEventListener('click', () => {
                    this.nodes.forEach(d => {
                        d.fx = d.x;
                        d.fy = d.y;
                    });
                });

                document.getElementById('reset-zoom').addEventListener('click', () => {
                    this.svg.transition()
                        .duration(750)
                        .call(this.zoom.transform, d3.zoomIdentity.scale(0.85));
                });
            }

            showTooltip(event, node) {
                let content = `<strong>${node.name}</strong><br>${node.description}`;
                if (node.paper) {
                    content = `<strong>${node.paper.title}</strong><br>${node.paper.journal} ${node.paper.year}<br>${node.paper.details}`;
                } else if (node.morePapers) {
                    content = `<strong>è¿½åŠ ã®è«–æ–‡</strong><br>`;
                    node.morePapers.forEach(paper => {
                        content += `ãƒ»${paper.title}<br>`;
                    });
                }
                this.tooltip.innerHTML = content;
                this.tooltip.classList.add('visible');
                this.updateTooltipPosition(event);
            }

            hideTooltip() {
                this.tooltip.classList.remove('visible');
            }

            updateTooltipPosition(event) {
                this.tooltip.style.left = `${event.clientX + 10}px`;
                this.tooltip.style.top = `${event.clientY - 10}px`;
            }

            showPaperTooltip(event, papers, categoryName) {
                let html = `<h4>ğŸ“š ${categoryName} ã®è«–æ–‡ä¸€è¦§ <span class="paper-count">${papers.length}</span></h4>`;
                
                papers.forEach(paper => {
                    html += `
                        <div class="paper-item">
                            <div class="paper-title">${paper.title}</div>
                            <div class="paper-meta">
                                ${paper.journal} ${paper.year} ${paper.details}
                            </div>
                        </div>
                    `;
                });
                
                this.paperTooltip.innerHTML = html;
                this.paperTooltip.classList.add('visible');
                this.updatePaperTooltipPosition(event);
            }

            hidePaperTooltip() {
                this.paperTooltip.classList.remove('visible');
            }

            updatePaperTooltipPosition(event) {
                const tooltipRect = this.paperTooltip.getBoundingClientRect();
                const windowWidth = window.innerWidth;
                const windowHeight = window.innerHeight;
                
                let left = event.clientX + 15;
                let top = event.clientY - 15;
                
                if (left + tooltipRect.width > windowWidth) {
                    left = event.clientX - tooltipRect.width - 15;
                }
                
                if (top + tooltipRect.height > windowHeight) {
                    top = windowHeight - tooltipRect.height - 10;
                }
                
                this.paperTooltip.style.left = `${left}px`;
                this.paperTooltip.style.top = `${top}px`;
            }
        }

        // ãƒšãƒ¼ã‚¸èª­ã¿è¾¼ã¿å®Œäº†æ™‚ã«ç³»çµ±æ¨¹ã‚’ä½œæˆ
        document.addEventListener('DOMContentLoaded', function() {
            new TreeChart('tree-chart', treeData);
        });
    </script>
</body>
</html>
